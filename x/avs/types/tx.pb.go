// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: exocore/avs/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// It is a two-phase submission with two values, 1 and 2
type Phase int32

const (
	// Default value when phase is not specified
	PhaseUnspecified Phase = 0
	// First phase where operators prepare and submit their initial responses
	PhasePrepare Phase = 1
	// Second phase where operators commit their prepared responses
	PhaseDoCommit Phase = 2
)

var Phase_name = map[int32]string{
	0: "PHASE_UNSPECIFIED",
	1: "PHASE_PREPARE",
	2: "PHASE_DO_COMMIT",
}

var Phase_value = map[string]int32{
	"PHASE_UNSPECIFIED": 0,
	"PHASE_PREPARE":     1,
	"PHASE_DO_COMMIT":   2,
}

func (x Phase) String() string {
	return proto.EnumName(Phase_name, int32(x))
}

func (Phase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{0}
}

// AVSinfo represent the information of avs
type AVSInfo struct {
	// name of avs as an arbitrary string
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// avs_address is the address of avs as a hex string
	AvsAddress string `protobuf:"bytes,2,opt,name=avs_address,json=avsAddress,proto3" json:"avs_address,omitempty"`
	// min_stake_amount is the minimum stake amount required for a task to start
	MinStakeAmount uint64 `protobuf:"varint,3,opt,name=min_stake_amount,json=minStakeAmount,proto3" json:"min_stake_amount,omitempty"`
	// task_addr is the address of task as a hex string
	TaskAddr string `protobuf:"bytes,4,opt,name=task_addr,json=taskAddr,proto3" json:"task_addr,omitempty"`
	// slash_addr is the hex address of the slashing contract for the AVS
	SlashAddr string `protobuf:"bytes,5,opt,name=slash_addr,json=slashAddr,proto3" json:"slash_addr,omitempty"`
	// reward_addr is the hex address of the reward contract for the AVS
	RewardAddr string `protobuf:"bytes,6,opt,name=reward_addr,json=rewardAddr,proto3" json:"reward_addr,omitempty"`
	// avs_owner_address are the bech32 addresses of the owners of the avs
	AvsOwnerAddress []string `protobuf:"bytes,7,rep,name=avs_owner_address,json=avsOwnerAddress,proto3" json:"avs_owner_address,omitempty"`
	// asset_ids is a list of asset_ids that the AVS accepts
	AssetIDs []string `protobuf:"bytes,8,rep,name=asset_ids,json=assetIds,proto3" json:"asset_ids,omitempty"`
	// avs_unbonding_period is the number of epochs that an operator must wait to unbond
	AvsUnbondingPeriod uint64 `protobuf:"varint,9,opt,name=avs_unbonding_period,json=avsUnbondingPeriod,proto3" json:"avs_unbonding_period,omitempty"`
	// min_self_delegation is the minimum self delegation required for an operator to join the AVS
	MinSelfDelegation uint64 `protobuf:"varint,10,opt,name=min_self_delegation,json=minSelfDelegation,proto3" json:"min_self_delegation,omitempty"`
	// epoch_identifier is the identifier from the epochs module
	EpochIdentifier string `protobuf:"bytes,11,opt,name=epoch_identifier,json=epochIdentifier,proto3" json:"epoch_identifier,omitempty"`
	// min_opt_in_operators is the minimum number of operators required for a task
	MinOptInOperators uint64 `protobuf:"varint,12,opt,name=min_opt_in_operators,json=minOptInOperators,proto3" json:"min_opt_in_operators,omitempty"`
	// min_total_stake_amount is the minimum total stake amount required for a task
	MinTotalStakeAmount uint64 `protobuf:"varint,13,opt,name=min_total_stake_amount,json=minTotalStakeAmount,proto3" json:"min_total_stake_amount,omitempty"`
	// starting_epoch is the epoch at which the AVS starts
	StartingEpoch uint64 `protobuf:"varint,14,opt,name=starting_epoch,json=startingEpoch,proto3" json:"starting_epoch,omitempty"`
	// chain_id is an optional parameter to specify the chain_id of the AVS, if any
	ChainId string `protobuf:"bytes,15,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// avs_reward defines the proportion of reward
	AvsReward github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,16,opt,name=avs_reward,json=avsReward,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"avs_reward"`
	// avs_slash defines the proportion of slash
	AvsSlash github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,17,opt,name=avs_slash,json=avsSlash,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"avs_slash"`
	// asset_reward_commission_epoch_basis is the avs reward distribution based on asset per eopch end.
	AssetRewardAmountEpochBasis map[string]int64 `protobuf:"bytes,18,rep,name=asset_reward_amount_epoch_basis,json=assetRewardAmountEpochBasis,proto3" json:"asset_reward_amount_epoch_basis,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *AVSInfo) Reset()         { *m = AVSInfo{} }
func (m *AVSInfo) String() string { return proto.CompactTextString(m) }
func (*AVSInfo) ProtoMessage()    {}
func (*AVSInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{0}
}
func (m *AVSInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AVSInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AVSInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AVSInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AVSInfo.Merge(m, src)
}
func (m *AVSInfo) XXX_Size() int {
	return m.Size()
}
func (m *AVSInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AVSInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AVSInfo proto.InternalMessageInfo

func (m *AVSInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AVSInfo) GetAvsAddress() string {
	if m != nil {
		return m.AvsAddress
	}
	return ""
}

func (m *AVSInfo) GetMinStakeAmount() uint64 {
	if m != nil {
		return m.MinStakeAmount
	}
	return 0
}

func (m *AVSInfo) GetTaskAddr() string {
	if m != nil {
		return m.TaskAddr
	}
	return ""
}

func (m *AVSInfo) GetSlashAddr() string {
	if m != nil {
		return m.SlashAddr
	}
	return ""
}

func (m *AVSInfo) GetRewardAddr() string {
	if m != nil {
		return m.RewardAddr
	}
	return ""
}

func (m *AVSInfo) GetAvsOwnerAddress() []string {
	if m != nil {
		return m.AvsOwnerAddress
	}
	return nil
}

func (m *AVSInfo) GetAssetIDs() []string {
	if m != nil {
		return m.AssetIDs
	}
	return nil
}

func (m *AVSInfo) GetAvsUnbondingPeriod() uint64 {
	if m != nil {
		return m.AvsUnbondingPeriod
	}
	return 0
}

func (m *AVSInfo) GetMinSelfDelegation() uint64 {
	if m != nil {
		return m.MinSelfDelegation
	}
	return 0
}

func (m *AVSInfo) GetEpochIdentifier() string {
	if m != nil {
		return m.EpochIdentifier
	}
	return ""
}

func (m *AVSInfo) GetMinOptInOperators() uint64 {
	if m != nil {
		return m.MinOptInOperators
	}
	return 0
}

func (m *AVSInfo) GetMinTotalStakeAmount() uint64 {
	if m != nil {
		return m.MinTotalStakeAmount
	}
	return 0
}

func (m *AVSInfo) GetStartingEpoch() uint64 {
	if m != nil {
		return m.StartingEpoch
	}
	return 0
}

func (m *AVSInfo) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *AVSInfo) GetAssetRewardAmountEpochBasis() map[string]int64 {
	if m != nil {
		return m.AssetRewardAmountEpochBasis
	}
	return nil
}

// Status and proof of each operator
type OperatorStatus struct {
	// operator address
	OperatorAddress string `protobuf:"bytes,1,opt,name=operator_address,json=operatorAddress,proto3" json:"operator_address,omitempty"`
	// Status of the operator,(slash,reward,no)
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// proof data which is supplied by the contract, usually ABI-encoded
	ProofData []byte `protobuf:"bytes,3,opt,name=proof_data,json=proofData,proto3" json:"proof_data,omitempty"`
}

func (m *OperatorStatus) Reset()         { *m = OperatorStatus{} }
func (m *OperatorStatus) String() string { return proto.CompactTextString(m) }
func (*OperatorStatus) ProtoMessage()    {}
func (*OperatorStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{1}
}
func (m *OperatorStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorStatus.Merge(m, src)
}
func (m *OperatorStatus) XXX_Size() int {
	return m.Size()
}
func (m *OperatorStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorStatus.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorStatus proto.InternalMessageInfo

func (m *OperatorStatus) GetOperatorAddress() string {
	if m != nil {
		return m.OperatorAddress
	}
	return ""
}

func (m *OperatorStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *OperatorStatus) GetProofData() []byte {
	if m != nil {
		return m.ProofData
	}
	return nil
}

// RewardSlashProof is the task info.
type RewardSlashProof struct {
	// task_id of task
	TaskId string `protobuf:"bytes,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// contract address of avstask
	TaskContractAddress string `protobuf:"bytes,2,opt,name=task_contract_address,json=taskContractAddress,proto3" json:"task_contract_address,omitempty"`
	// aggregator  address
	Aggregator string `protobuf:"bytes,3,opt,name=aggregator,proto3" json:"aggregator,omitempty"`
	// address of avs
	AvsAddress string `protobuf:"bytes,4,opt,name=avs_address,json=avsAddress,proto3" json:"avs_address,omitempty"`
	// Status and proof of  operators
	OperatorStatus []*OperatorStatus `protobuf:"bytes,5,rep,name=operator_status,json=operatorStatus,proto3" json:"operator_status,omitempty"`
}

func (m *RewardSlashProof) Reset()         { *m = RewardSlashProof{} }
func (m *RewardSlashProof) String() string { return proto.CompactTextString(m) }
func (*RewardSlashProof) ProtoMessage()    {}
func (*RewardSlashProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{2}
}
func (m *RewardSlashProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardSlashProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardSlashProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardSlashProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardSlashProof.Merge(m, src)
}
func (m *RewardSlashProof) XXX_Size() int {
	return m.Size()
}
func (m *RewardSlashProof) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardSlashProof.DiscardUnknown(m)
}

var xxx_messageInfo_RewardSlashProof proto.InternalMessageInfo

func (m *RewardSlashProof) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *RewardSlashProof) GetTaskContractAddress() string {
	if m != nil {
		return m.TaskContractAddress
	}
	return ""
}

func (m *RewardSlashProof) GetAggregator() string {
	if m != nil {
		return m.Aggregator
	}
	return ""
}

func (m *RewardSlashProof) GetAvsAddress() string {
	if m != nil {
		return m.AvsAddress
	}
	return ""
}

func (m *RewardSlashProof) GetOperatorStatus() []*OperatorStatus {
	if m != nil {
		return m.OperatorStatus
	}
	return nil
}

// TaskContractInfo is the task info.
type TaskInfo struct {
	// contract address of avstask
	TaskContractAddress string `protobuf:"bytes,1,opt,name=task_contract_address,json=taskContractAddress,proto3" json:"task_contract_address,omitempty"`
	// name of task
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// data which is supplied by the contract, usually ABI-encoded
	Hash []byte `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	// task_id of task
	TaskId uint64 `protobuf:"varint,4,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// Deadline for task response
	TaskResponsePeriod uint64 `protobuf:"varint,5,opt,name=task_response_period,json=taskResponsePeriod,proto3" json:"task_response_period,omitempty"`
	// Statistical period: threshold calculation, signature verification,
	// nosig quantity statistics, operator submits messages corresponding to signatures
	TaskStatisticalPeriod uint64 `protobuf:"varint,6,opt,name=task_statistical_period,json=taskStatisticalPeriod,proto3" json:"task_statistical_period,omitempty"`
	// challenge period for  task
	TaskChallengePeriod uint64 `protobuf:"varint,7,opt,name=task_challenge_period,json=taskChallengePeriod,proto3" json:"task_challenge_period,omitempty"`
	// Signature threshold percentage
	ThresholdPercentage uint64 `protobuf:"varint,8,opt,name=threshold_percentage,json=thresholdPercentage,proto3" json:"threshold_percentage,omitempty"`
	// Effective current epoch, accounting for current_epoch + 1
	// and current_epoch is the integer identifier of the epoch module
	StartingEpoch uint64 `protobuf:"varint,9,opt,name=starting_epoch,json=startingEpoch,proto3" json:"starting_epoch,omitempty"`
	// actual_threshold is the Actual threshold
	ActualThreshold uint64 `protobuf:"varint,10,opt,name=actual_threshold,json=actualThreshold,proto3" json:"actual_threshold,omitempty"`
	// opt_in_count when creating a task, the actual opt-in operator counts at this moment
	OptInOperators []string `protobuf:"bytes,11,rep,name=opt_in_operators,json=optInOperators,proto3" json:"opt_in_operators,omitempty"`
	// signed_count is Actual number of signatures already signed
	SignedOperators []string `protobuf:"bytes,12,rep,name=signed_operators,json=signedOperators,proto3" json:"signed_operators,omitempty"`
	// no_signed_count is the final number of unsigned operators
	NoSignedOperators []string `protobuf:"bytes,13,rep,name=no_signed_operators,json=noSignedOperators,proto3" json:"no_signed_operators,omitempty"`
	// err_signed_count is the number of operators with final incorrect signatures
	ErrSignedOperators []string `protobuf:"bytes,14,rep,name=err_signed_operators,json=errSignedOperators,proto3" json:"err_signed_operators,omitempty"`
	// task_total_power is the USD value owned by the avs task itself.
	TaskTotalPower github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,15,opt,name=task_total_power,json=taskTotalPower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"task_total_power"`
	// operator_active_power_list is a power list of operators opt-in to the current task
	OperatorActivePower *OperatorActivePowerList `protobuf:"bytes,16,opt,name=operator_active_power,json=operatorActivePower,proto3" json:"operator_active_power,omitempty"`
}

func (m *TaskInfo) Reset()         { *m = TaskInfo{} }
func (m *TaskInfo) String() string { return proto.CompactTextString(m) }
func (*TaskInfo) ProtoMessage()    {}
func (*TaskInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{3}
}
func (m *TaskInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskInfo.Merge(m, src)
}
func (m *TaskInfo) XXX_Size() int {
	return m.Size()
}
func (m *TaskInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TaskInfo proto.InternalMessageInfo

func (m *TaskInfo) GetTaskContractAddress() string {
	if m != nil {
		return m.TaskContractAddress
	}
	return ""
}

func (m *TaskInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TaskInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *TaskInfo) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *TaskInfo) GetTaskResponsePeriod() uint64 {
	if m != nil {
		return m.TaskResponsePeriod
	}
	return 0
}

func (m *TaskInfo) GetTaskStatisticalPeriod() uint64 {
	if m != nil {
		return m.TaskStatisticalPeriod
	}
	return 0
}

func (m *TaskInfo) GetTaskChallengePeriod() uint64 {
	if m != nil {
		return m.TaskChallengePeriod
	}
	return 0
}

func (m *TaskInfo) GetThresholdPercentage() uint64 {
	if m != nil {
		return m.ThresholdPercentage
	}
	return 0
}

func (m *TaskInfo) GetStartingEpoch() uint64 {
	if m != nil {
		return m.StartingEpoch
	}
	return 0
}

func (m *TaskInfo) GetActualThreshold() uint64 {
	if m != nil {
		return m.ActualThreshold
	}
	return 0
}

func (m *TaskInfo) GetOptInOperators() []string {
	if m != nil {
		return m.OptInOperators
	}
	return nil
}

func (m *TaskInfo) GetSignedOperators() []string {
	if m != nil {
		return m.SignedOperators
	}
	return nil
}

func (m *TaskInfo) GetNoSignedOperators() []string {
	if m != nil {
		return m.NoSignedOperators
	}
	return nil
}

func (m *TaskInfo) GetErrSignedOperators() []string {
	if m != nil {
		return m.ErrSignedOperators
	}
	return nil
}

func (m *TaskInfo) GetOperatorActivePower() *OperatorActivePowerList {
	if m != nil {
		return m.OperatorActivePower
	}
	return nil
}

// OperatorActivePowerList is the power list of operators opt-in to the current task.
// Because power is always changing, record the power of all operators
// who have completed tasks and submitted results by the task deadline
type OperatorActivePowerList struct {
	// operator_power_list is a power list of operators.
	OperatorPowerList []*OperatorActivePowerInfo `protobuf:"bytes,1,rep,name=operator_power_list,json=operatorPowerList,proto3" json:"operator_power_list,omitempty"`
}

func (m *OperatorActivePowerList) Reset()         { *m = OperatorActivePowerList{} }
func (m *OperatorActivePowerList) String() string { return proto.CompactTextString(m) }
func (*OperatorActivePowerList) ProtoMessage()    {}
func (*OperatorActivePowerList) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{4}
}
func (m *OperatorActivePowerList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorActivePowerList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorActivePowerList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorActivePowerList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorActivePowerList.Merge(m, src)
}
func (m *OperatorActivePowerList) XXX_Size() int {
	return m.Size()
}
func (m *OperatorActivePowerList) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorActivePowerList.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorActivePowerList proto.InternalMessageInfo

func (m *OperatorActivePowerList) GetOperatorPowerList() []*OperatorActivePowerInfo {
	if m != nil {
		return m.OperatorPowerList
	}
	return nil
}

// OperatorActivePowerInfo is the operator power info.
type OperatorActivePowerInfo struct {
	// operator_addr is the operator  address.
	OperatorAddr string `protobuf:"bytes,1,opt,name=operator_addr,json=operatorAddr,proto3" json:"operator_addr,omitempty"`
	// active_power is the USD value owned by the operator itself.
	SelfActivePower github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=active_power,json=activePower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"active_power"`
}

func (m *OperatorActivePowerInfo) Reset()         { *m = OperatorActivePowerInfo{} }
func (m *OperatorActivePowerInfo) String() string { return proto.CompactTextString(m) }
func (*OperatorActivePowerInfo) ProtoMessage()    {}
func (*OperatorActivePowerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{5}
}
func (m *OperatorActivePowerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorActivePowerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorActivePowerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorActivePowerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorActivePowerInfo.Merge(m, src)
}
func (m *OperatorActivePowerInfo) XXX_Size() int {
	return m.Size()
}
func (m *OperatorActivePowerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorActivePowerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorActivePowerInfo proto.InternalMessageInfo

func (m *OperatorActivePowerInfo) GetOperatorAddr() string {
	if m != nil {
		return m.OperatorAddr
	}
	return ""
}

// BlsPubKeyInfo is the task info.
type BlsPubKeyInfo struct {
	// operator address
	Operator string `protobuf:"bytes,1,opt,name=operator,proto3" json:"operator,omitempty"`
	// the name of public keys
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// the bls public keys of the operator
	PubKey []byte `protobuf:"bytes,3,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
}

func (m *BlsPubKeyInfo) Reset()         { *m = BlsPubKeyInfo{} }
func (m *BlsPubKeyInfo) String() string { return proto.CompactTextString(m) }
func (*BlsPubKeyInfo) ProtoMessage()    {}
func (*BlsPubKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{6}
}
func (m *BlsPubKeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlsPubKeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlsPubKeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlsPubKeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlsPubKeyInfo.Merge(m, src)
}
func (m *BlsPubKeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *BlsPubKeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlsPubKeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BlsPubKeyInfo proto.InternalMessageInfo

func (m *BlsPubKeyInfo) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *BlsPubKeyInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlsPubKeyInfo) GetPubKey() []byte {
	if m != nil {
		return m.PubKey
	}
	return nil
}

// RegisterAVSTaskReq is the request to register a new task for avs.
type RegisterAVSTaskReq struct {
	// from_address is the address of the avs (sdk.AccAddress).
	FromAddress string `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	// info is the task info.
	Task *TaskInfo `protobuf:"bytes,2,opt,name=task,proto3" json:"task,omitempty"`
}

func (m *RegisterAVSTaskReq) Reset()         { *m = RegisterAVSTaskReq{} }
func (m *RegisterAVSTaskReq) String() string { return proto.CompactTextString(m) }
func (*RegisterAVSTaskReq) ProtoMessage()    {}
func (*RegisterAVSTaskReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{7}
}
func (m *RegisterAVSTaskReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterAVSTaskReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterAVSTaskReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterAVSTaskReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterAVSTaskReq.Merge(m, src)
}
func (m *RegisterAVSTaskReq) XXX_Size() int {
	return m.Size()
}
func (m *RegisterAVSTaskReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterAVSTaskReq.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterAVSTaskReq proto.InternalMessageInfo

// RegisterAVSTaskResponse is the response for register avs task
type RegisterAVSTaskResponse struct {
}

func (m *RegisterAVSTaskResponse) Reset()         { *m = RegisterAVSTaskResponse{} }
func (m *RegisterAVSTaskResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterAVSTaskResponse) ProtoMessage()    {}
func (*RegisterAVSTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{8}
}
func (m *RegisterAVSTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterAVSTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterAVSTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterAVSTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterAVSTaskResponse.Merge(m, src)
}
func (m *RegisterAVSTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegisterAVSTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterAVSTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterAVSTaskResponse proto.InternalMessageInfo

// RegisterAVSReq is requst to register avs
type RegisterAVSReq struct {
	// from_address is the source
	FromAddress string `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	// avs information
	Info *AVSInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *RegisterAVSReq) Reset()         { *m = RegisterAVSReq{} }
func (m *RegisterAVSReq) String() string { return proto.CompactTextString(m) }
func (*RegisterAVSReq) ProtoMessage()    {}
func (*RegisterAVSReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{9}
}
func (m *RegisterAVSReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterAVSReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterAVSReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterAVSReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterAVSReq.Merge(m, src)
}
func (m *RegisterAVSReq) XXX_Size() int {
	return m.Size()
}
func (m *RegisterAVSReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterAVSReq.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterAVSReq proto.InternalMessageInfo

func (m *RegisterAVSReq) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *RegisterAVSReq) GetInfo() *AVSInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// RegisterAVSResponse is the response for register avs
type RegisterAVSResponse struct {
	// from_address is the source
	FromAddress string `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	// avs information
	Info *AVSInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *RegisterAVSResponse) Reset()         { *m = RegisterAVSResponse{} }
func (m *RegisterAVSResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterAVSResponse) ProtoMessage()    {}
func (*RegisterAVSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{10}
}
func (m *RegisterAVSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterAVSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterAVSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterAVSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterAVSResponse.Merge(m, src)
}
func (m *RegisterAVSResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegisterAVSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterAVSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterAVSResponse proto.InternalMessageInfo

func (m *RegisterAVSResponse) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *RegisterAVSResponse) GetInfo() *AVSInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// DeRegisterAVSReq is requst to deregister avs
type DeRegisterAVSReq struct {
	// from_address is the source address
	FromAddress string `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	// avs information
	Info *AVSInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *DeRegisterAVSReq) Reset()         { *m = DeRegisterAVSReq{} }
func (m *DeRegisterAVSReq) String() string { return proto.CompactTextString(m) }
func (*DeRegisterAVSReq) ProtoMessage()    {}
func (*DeRegisterAVSReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{11}
}
func (m *DeRegisterAVSReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeRegisterAVSReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeRegisterAVSReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeRegisterAVSReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeRegisterAVSReq.Merge(m, src)
}
func (m *DeRegisterAVSReq) XXX_Size() int {
	return m.Size()
}
func (m *DeRegisterAVSReq) XXX_DiscardUnknown() {
	xxx_messageInfo_DeRegisterAVSReq.DiscardUnknown(m)
}

var xxx_messageInfo_DeRegisterAVSReq proto.InternalMessageInfo

func (m *DeRegisterAVSReq) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *DeRegisterAVSReq) GetInfo() *AVSInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// DeRegisterAVSResponse is requst to register avs
type DeRegisterAVSResponse struct {
	// from_address is the source address
	FromAddress string `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	// avs information
	Info *AVSInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *DeRegisterAVSResponse) Reset()         { *m = DeRegisterAVSResponse{} }
func (m *DeRegisterAVSResponse) String() string { return proto.CompactTextString(m) }
func (*DeRegisterAVSResponse) ProtoMessage()    {}
func (*DeRegisterAVSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{12}
}
func (m *DeRegisterAVSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeRegisterAVSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeRegisterAVSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeRegisterAVSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeRegisterAVSResponse.Merge(m, src)
}
func (m *DeRegisterAVSResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeRegisterAVSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeRegisterAVSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeRegisterAVSResponse proto.InternalMessageInfo

func (m *DeRegisterAVSResponse) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *DeRegisterAVSResponse) GetInfo() *AVSInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

// TaskResultInfo is the operator sign task info result.
type TaskResultInfo struct {
	// operator_address operator address
	OperatorAddress string `protobuf:"bytes,1,opt,name=operator_address,json=operatorAddress,proto3" json:"operator_address,omitempty"`
	// task_response_hash is the task_response msg hash.
	TaskResponseHash string `protobuf:"bytes,2,opt,name=task_response_hash,json=taskResponseHash,proto3" json:"task_response_hash,omitempty"`
	// task_response is the task response data.
	TaskResponse []byte `protobuf:"bytes,3,opt,name=task_response,json=taskResponse,proto3" json:"task_response,omitempty"`
	// bls_signature is the operator bls sig info.
	BlsSignature []byte `protobuf:"bytes,4,opt,name=bls_signature,json=blsSignature,proto3" json:"bls_signature,omitempty"`
	// task_contract_address is contract address of task
	TaskContractAddress string `protobuf:"bytes,5,opt,name=task_contract_address,json=taskContractAddress,proto3" json:"task_contract_address,omitempty"`
	// task_id is the  task id
	TaskId uint64 `protobuf:"varint,6,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	// phase this field is used to solve the problem of task results being copied by other operators.
	// It is a two-phase submission with two values, 1 and 2
	Phase Phase `protobuf:"varint,7,opt,name=phase,proto3,enum=exocore.avs.v1.Phase" json:"phase,omitempty"`
}

func (m *TaskResultInfo) Reset()         { *m = TaskResultInfo{} }
func (m *TaskResultInfo) String() string { return proto.CompactTextString(m) }
func (*TaskResultInfo) ProtoMessage()    {}
func (*TaskResultInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{13}
}
func (m *TaskResultInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TaskResultInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TaskResultInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TaskResultInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TaskResultInfo.Merge(m, src)
}
func (m *TaskResultInfo) XXX_Size() int {
	return m.Size()
}
func (m *TaskResultInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TaskResultInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TaskResultInfo proto.InternalMessageInfo

func (m *TaskResultInfo) GetOperatorAddress() string {
	if m != nil {
		return m.OperatorAddress
	}
	return ""
}

func (m *TaskResultInfo) GetTaskResponseHash() string {
	if m != nil {
		return m.TaskResponseHash
	}
	return ""
}

func (m *TaskResultInfo) GetTaskResponse() []byte {
	if m != nil {
		return m.TaskResponse
	}
	return nil
}

func (m *TaskResultInfo) GetBlsSignature() []byte {
	if m != nil {
		return m.BlsSignature
	}
	return nil
}

func (m *TaskResultInfo) GetTaskContractAddress() string {
	if m != nil {
		return m.TaskContractAddress
	}
	return ""
}

func (m *TaskResultInfo) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *TaskResultInfo) GetPhase() Phase {
	if m != nil {
		return m.Phase
	}
	return PhaseUnspecified
}

// SubmitTaskResultReq is the request to submit task results.
type SubmitTaskResultReq struct {
	// from_address is the address of the operator (sdk.AccAddress).
	FromAddress string `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	// info is the taskResult.
	Info *TaskResultInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *SubmitTaskResultReq) Reset()         { *m = SubmitTaskResultReq{} }
func (m *SubmitTaskResultReq) String() string { return proto.CompactTextString(m) }
func (*SubmitTaskResultReq) ProtoMessage()    {}
func (*SubmitTaskResultReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{14}
}
func (m *SubmitTaskResultReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitTaskResultReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitTaskResultReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitTaskResultReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitTaskResultReq.Merge(m, src)
}
func (m *SubmitTaskResultReq) XXX_Size() int {
	return m.Size()
}
func (m *SubmitTaskResultReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitTaskResultReq.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitTaskResultReq proto.InternalMessageInfo

// SubmitTaskResultResponse is the response to submit task results.
type SubmitTaskResultResponse struct {
}

func (m *SubmitTaskResultResponse) Reset()         { *m = SubmitTaskResultResponse{} }
func (m *SubmitTaskResultResponse) String() string { return proto.CompactTextString(m) }
func (*SubmitTaskResultResponse) ProtoMessage()    {}
func (*SubmitTaskResultResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ef1ed06249b07d86, []int{15}
}
func (m *SubmitTaskResultResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitTaskResultResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitTaskResultResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitTaskResultResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitTaskResultResponse.Merge(m, src)
}
func (m *SubmitTaskResultResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubmitTaskResultResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitTaskResultResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitTaskResultResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("exocore.avs.v1.Phase", Phase_name, Phase_value)
	proto.RegisterType((*AVSInfo)(nil), "exocore.avs.v1.AVSInfo")
	proto.RegisterMapType((map[string]int64)(nil), "exocore.avs.v1.AVSInfo.AssetRewardAmountEpochBasisEntry")
	proto.RegisterType((*OperatorStatus)(nil), "exocore.avs.v1.OperatorStatus")
	proto.RegisterType((*RewardSlashProof)(nil), "exocore.avs.v1.RewardSlashProof")
	proto.RegisterType((*TaskInfo)(nil), "exocore.avs.v1.TaskInfo")
	proto.RegisterType((*OperatorActivePowerList)(nil), "exocore.avs.v1.OperatorActivePowerList")
	proto.RegisterType((*OperatorActivePowerInfo)(nil), "exocore.avs.v1.OperatorActivePowerInfo")
	proto.RegisterType((*BlsPubKeyInfo)(nil), "exocore.avs.v1.BlsPubKeyInfo")
	proto.RegisterType((*RegisterAVSTaskReq)(nil), "exocore.avs.v1.RegisterAVSTaskReq")
	proto.RegisterType((*RegisterAVSTaskResponse)(nil), "exocore.avs.v1.RegisterAVSTaskResponse")
	proto.RegisterType((*RegisterAVSReq)(nil), "exocore.avs.v1.RegisterAVSReq")
	proto.RegisterType((*RegisterAVSResponse)(nil), "exocore.avs.v1.RegisterAVSResponse")
	proto.RegisterType((*DeRegisterAVSReq)(nil), "exocore.avs.v1.DeRegisterAVSReq")
	proto.RegisterType((*DeRegisterAVSResponse)(nil), "exocore.avs.v1.DeRegisterAVSResponse")
	proto.RegisterType((*TaskResultInfo)(nil), "exocore.avs.v1.TaskResultInfo")
	proto.RegisterType((*SubmitTaskResultReq)(nil), "exocore.avs.v1.SubmitTaskResultReq")
	proto.RegisterType((*SubmitTaskResultResponse)(nil), "exocore.avs.v1.SubmitTaskResultResponse")
}

func init() { proto.RegisterFile("exocore/avs/v1/tx.proto", fileDescriptor_ef1ed06249b07d86) }

var fileDescriptor_ef1ed06249b07d86 = []byte{
	// 1787 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x41, 0x6f, 0x1b, 0xc7,
	0x15, 0xd6, 0x4a, 0x94, 0x44, 0x3e, 0x52, 0x14, 0x35, 0xa2, 0xc3, 0x35, 0xdd, 0x92, 0xc4, 0xba,
	0x76, 0x64, 0x39, 0x26, 0x6d, 0xa5, 0x28, 0x0c, 0xf7, 0x24, 0x59, 0x4a, 0x42, 0xa4, 0xb6, 0x88,
	0xa5, 0x9c, 0x16, 0xed, 0x61, 0x31, 0xe4, 0x8e, 0xc8, 0x85, 0xc8, 0x1d, 0x76, 0x67, 0x48, 0xdb,
	0x3d, 0x14, 0x85, 0x2f, 0x0d, 0x84, 0xa2, 0x68, 0x91, 0xb3, 0x81, 0x00, 0x3d, 0x16, 0x05, 0x8c,
	0x22, 0x97, 0x02, 0xed, 0x3d, 0xc7, 0x20, 0xbd, 0x14, 0x3d, 0x18, 0x85, 0x5c, 0xc0, 0xed, 0xbf,
	0x28, 0xe6, 0xed, 0x2c, 0xc5, 0x25, 0x25, 0xbb, 0x6e, 0x0e, 0xf5, 0xc5, 0xda, 0x79, 0xdf, 0x7b,
	0x6f, 0xde, 0x7b, 0x33, 0xef, 0x7b, 0x63, 0x42, 0x81, 0x3d, 0xe2, 0x6d, 0x1e, 0xb0, 0x1a, 0x1d,
	0x89, 0xda, 0xe8, 0x56, 0x4d, 0x3e, 0xaa, 0x0e, 0x02, 0x2e, 0x39, 0xc9, 0x6a, 0xa0, 0x4a, 0x47,
	0xa2, 0x3a, 0xba, 0x55, 0x5c, 0xa3, 0x7d, 0xcf, 0xe7, 0x35, 0xfc, 0x37, 0x54, 0x29, 0x16, 0xda,
	0x5c, 0xf4, 0xb9, 0xa8, 0xf5, 0x45, 0x47, 0x99, 0xf6, 0x45, 0x47, 0x03, 0x17, 0x43, 0xc0, 0xc1,
	0x55, 0x2d, 0x5c, 0x68, 0x28, 0xdf, 0xe1, 0x1d, 0x1e, 0xca, 0xd5, 0x97, 0x96, 0x7e, 0xab, 0xc3,
	0x79, 0xa7, 0xc7, 0x6a, 0x74, 0xe0, 0xd5, 0xa8, 0xef, 0x73, 0x49, 0xa5, 0xc7, 0x7d, 0x6d, 0x63,
	0xfd, 0x65, 0x19, 0x96, 0xb7, 0x3f, 0x69, 0xd6, 0xfd, 0x43, 0x4e, 0x08, 0x24, 0x7c, 0xda, 0x67,
	0xa6, 0x51, 0x31, 0x36, 0x52, 0x36, 0x7e, 0x93, 0x32, 0xa4, 0xe9, 0x48, 0x38, 0xd4, 0x75, 0x03,
	0x26, 0x84, 0x39, 0x8f, 0x10, 0xd0, 0x91, 0xd8, 0x0e, 0x25, 0x64, 0x03, 0x72, 0x7d, 0xcf, 0x77,
	0x84, 0xa4, 0x47, 0xcc, 0xa1, 0x7d, 0x3e, 0xf4, 0xa5, 0xb9, 0x50, 0x31, 0x36, 0x12, 0x76, 0xb6,
	0xef, 0xf9, 0x4d, 0x25, 0xde, 0x46, 0x29, 0xb9, 0x04, 0x29, 0x49, 0xc5, 0x11, 0xfa, 0x32, 0x13,
	0xe8, 0x28, 0xa9, 0x04, 0xca, 0x13, 0xf9, 0x36, 0x80, 0xe8, 0x51, 0xd1, 0x0d, 0xd1, 0x45, 0x44,
	0x53, 0x28, 0x41, 0xb8, 0x0c, 0xe9, 0x80, 0x3d, 0xa4, 0x81, 0x1b, 0xe2, 0x4b, 0x61, 0x18, 0xa1,
	0x08, 0x15, 0x36, 0x61, 0x4d, 0xc5, 0xc9, 0x1f, 0xfa, 0x2c, 0x18, 0x47, 0xbb, 0x5c, 0x59, 0xd8,
	0x48, 0xd9, 0xab, 0x74, 0x24, 0xf6, 0x95, 0x3c, 0x0a, 0xf9, 0x1a, 0xa4, 0xa8, 0x10, 0x4c, 0x3a,
	0x9e, 0x2b, 0xcc, 0xa4, 0xd2, 0xd9, 0xc9, 0x9c, 0x3c, 0x2f, 0x27, 0xb7, 0x95, 0xb0, 0xbe, 0x2b,
	0xec, 0x24, 0xc2, 0x75, 0x57, 0x90, 0x9b, 0x90, 0x57, 0x6e, 0x87, 0x7e, 0x8b, 0xfb, 0xae, 0xe7,
	0x77, 0x9c, 0x01, 0x0b, 0x3c, 0xee, 0x9a, 0x29, 0xcc, 0x90, 0xd0, 0x91, 0x78, 0x10, 0x41, 0x0d,
	0x44, 0x48, 0x15, 0xd6, 0xb1, 0x1e, 0xac, 0x77, 0xe8, 0xb8, 0xac, 0xc7, 0x3a, 0x58, 0x6e, 0x13,
	0xd0, 0x60, 0x4d, 0x95, 0x84, 0xf5, 0x0e, 0x77, 0xc7, 0x00, 0xb9, 0x06, 0x39, 0x36, 0xe0, 0xed,
	0xae, 0xe3, 0xb9, 0xcc, 0x97, 0xde, 0xa1, 0xc7, 0x02, 0x33, 0x8d, 0xe9, 0xad, 0xa2, 0xbc, 0x3e,
	0x16, 0x93, 0x1a, 0xe4, 0x95, 0x6b, 0x3e, 0x90, 0x0e, 0xfe, 0x61, 0x01, 0x95, 0x3c, 0x10, 0x66,
	0x66, 0xec, 0x7b, 0x7f, 0x20, 0xeb, 0xfe, 0x7e, 0x04, 0x90, 0xf7, 0xe1, 0x1d, 0x65, 0x20, 0xb9,
	0xa4, 0xbd, 0xf8, 0x09, 0xad, 0xa0, 0x89, 0x8a, 0xf4, 0x40, 0x81, 0x93, 0xc7, 0x74, 0x05, 0xb2,
	0x42, 0xd2, 0x40, 0xaa, 0x6c, 0x31, 0x02, 0x33, 0x8b, 0xca, 0x2b, 0x91, 0x74, 0x4f, 0x09, 0xc9,
	0x45, 0x48, 0xb6, 0xbb, 0xd4, 0xf3, 0x1d, 0xcf, 0x35, 0x57, 0x31, 0xde, 0x65, 0x5c, 0xd7, 0x5d,
	0x72, 0x0f, 0xd4, 0x05, 0x71, 0xc2, 0xd3, 0x31, 0x73, 0x0a, 0xdc, 0xa9, 0x7e, 0xf9, 0xbc, 0x3c,
	0xf7, 0xf7, 0xe7, 0xe5, 0xab, 0x1d, 0x4f, 0x76, 0x87, 0xad, 0x6a, 0x9b, 0xf7, 0xf5, 0xe5, 0xd5,
	0x7f, 0x6e, 0x08, 0xf7, 0xa8, 0x26, 0x1f, 0x0f, 0x98, 0xa8, 0xee, 0xb2, 0xb6, 0x9d, 0xa2, 0x23,
	0x61, 0xa3, 0x03, 0xf2, 0x31, 0xa8, 0x85, 0x83, 0x97, 0xc1, 0x5c, 0xfb, 0x9f, 0xbc, 0x25, 0xe9,
	0x48, 0x34, 0x95, 0x3d, 0xf9, 0x39, 0x94, 0xc3, 0xb3, 0x8f, 0xae, 0x13, 0x26, 0x1d, 0x26, 0xea,
	0xb4, 0xa8, 0xf0, 0x84, 0x49, 0x2a, 0x0b, 0x1b, 0xe9, 0xad, 0xdb, 0xd5, 0x78, 0x93, 0x56, 0x75,
	0x97, 0x54, 0xf1, 0x96, 0x84, 0xa1, 0x85, 0x15, 0xc3, 0x7a, 0xec, 0x28, 0xd3, 0x3d, 0x5f, 0x06,
	0x8f, 0xed, 0x4b, 0xf4, 0x7c, 0x8d, 0xe2, 0x7d, 0xa8, 0xbc, 0xce, 0x01, 0xc9, 0xc1, 0xc2, 0x11,
	0x7b, 0xac, 0xdb, 0x50, 0x7d, 0x92, 0x3c, 0x2c, 0x8e, 0x68, 0x6f, 0xc8, 0xb0, 0xff, 0x16, 0xec,
	0x70, 0x71, 0x67, 0xfe, 0xb6, 0x61, 0x05, 0x90, 0x8d, 0xce, 0xbb, 0x29, 0xa9, 0x1c, 0xaa, 0xdb,
	0x9d, 0x8b, 0xae, 0xc6, 0xb8, 0x11, 0x42, 0x57, 0xab, 0x91, 0x3c, 0x6a, 0x84, 0x77, 0x60, 0x49,
	0xa0, 0x91, 0xee, 0x6b, 0xbd, 0x52, 0xcd, 0x38, 0x08, 0x38, 0x3f, 0x74, 0x5c, 0x2a, 0x29, 0x76,
	0x73, 0xc6, 0x4e, 0xa1, 0x64, 0x97, 0x4a, 0x6a, 0xfd, 0xdb, 0x80, 0x5c, 0x18, 0x3f, 0xd6, 0xb4,
	0xa1, 0x00, 0x52, 0x80, 0x65, 0xec, 0x6e, 0xcf, 0xd5, 0xbb, 0x2d, 0xa9, 0x65, 0xdd, 0x25, 0x5b,
	0x70, 0x01, 0x81, 0x36, 0xf7, 0x65, 0x40, 0xdb, 0x72, 0x8a, 0x4b, 0xd6, 0x15, 0x78, 0x57, 0x63,
	0x51, 0x60, 0x25, 0x00, 0xda, 0xe9, 0x04, 0xaa, 0x47, 0x78, 0x80, 0x01, 0x28, 0xd2, 0x19, 0x4b,
	0xa6, 0x59, 0x29, 0x31, 0xc3, 0x4a, 0x1f, 0xc2, 0x38, 0x59, 0x47, 0xa7, 0xb8, 0x88, 0xc7, 0x5a,
	0x9a, 0x3e, 0xd6, 0x78, 0xf5, 0xec, 0x2c, 0x8f, 0xad, 0xad, 0x67, 0x4b, 0x90, 0x3c, 0x50, 0x89,
	0x28, 0x82, 0x3c, 0x37, 0x15, 0xe3, 0xfc, 0x54, 0x22, 0x52, 0x9d, 0x9f, 0x20, 0x55, 0x02, 0x89,
	0xae, 0xba, 0xcc, 0x61, 0x65, 0xf1, 0x7b, 0xb2, 0x7e, 0x09, 0xec, 0xb7, 0xa8, 0x7e, 0x37, 0x21,
	0x8f, 0x40, 0xc0, 0xc4, 0x80, 0xfb, 0x82, 0x45, 0x14, 0xb4, 0x18, 0x52, 0x90, 0xc2, 0x6c, 0x0d,
	0x69, 0x0a, 0xfa, 0x1e, 0x14, 0xd0, 0x42, 0x25, 0xee, 0x09, 0xe9, 0xb5, 0x69, 0x2f, 0x32, 0x5a,
	0x42, 0x23, 0xcc, 0xa2, 0x79, 0x8a, 0x6a, 0xbb, 0x71, 0x7a, 0x5d, 0xda, 0xeb, 0x31, 0xbf, 0x33,
	0xde, 0x6a, 0x39, 0x64, 0x0b, 0x4c, 0x2f, 0xc2, 0xb4, 0xcd, 0x2d, 0xc8, 0xcb, 0x6e, 0xc0, 0x44,
	0x97, 0xf7, 0x5c, 0xa5, 0xde, 0x66, 0xbe, 0xa4, 0x1d, 0x66, 0x26, 0xb5, 0x49, 0x84, 0x35, 0xc6,
	0xd0, 0x19, 0x04, 0x93, 0x3a, 0x8b, 0x60, 0xae, 0x41, 0x8e, 0xb6, 0xe5, 0x90, 0xf6, 0x9c, 0xb1,
	0x13, 0xcd, 0xa2, 0xab, 0xa1, 0xfc, 0x20, 0x12, 0xab, 0x19, 0x34, 0x43, 0x8a, 0x69, 0xe4, 0xfe,
	0x2c, 0x8f, 0x33, 0xe2, 0x35, 0xc8, 0x09, 0xaf, 0xe3, 0x33, 0x37, 0x46, 0x9f, 0x38, 0x25, 0x42,
	0xf9, 0xa9, 0x6a, 0x15, 0xd6, 0x7d, 0xee, 0xcc, 0x68, 0xaf, 0xa0, 0xf6, 0x9a, 0xcf, 0x9b, 0x53,
	0xfa, 0x37, 0x21, 0xcf, 0x82, 0x60, 0xd6, 0x20, 0x8b, 0x06, 0x84, 0x05, 0xc1, 0xb4, 0xc5, 0x23,
	0xc8, 0x61, 0xbd, 0x43, 0x7e, 0x1e, 0xf0, 0x87, 0x2c, 0x08, 0xa9, 0x74, 0xe7, 0xfe, 0x9b, 0xf1,
	0xdb, 0xc9, 0xf3, 0x72, 0x56, 0x5d, 0x52, 0xe4, 0xf2, 0x86, 0xf2, 0xf3, 0xf5, 0x17, 0x37, 0x40,
	0xbf, 0x0d, 0x14, 0xff, 0x65, 0x65, 0x0c, 0x25, 0x3f, 0x81, 0x0b, 0xa7, 0x1c, 0xd1, 0x96, 0xde,
	0x88, 0xe9, 0xed, 0x15, 0x59, 0xa7, 0xb7, 0xde, 0x3d, 0xaf, 0x49, 0xb6, 0x51, 0x17, 0x7d, 0xfc,
	0xc0, 0x13, 0xd2, 0x5e, 0xe7, 0xb3, 0x80, 0x15, 0x40, 0xe1, 0x1c, 0x7d, 0xf2, 0x43, 0x18, 0x5b,
	0x84, 0x1b, 0x3a, 0x3d, 0x4f, 0x48, 0xd3, 0xc0, 0xd6, 0xfc, 0x6f, 0x76, 0x55, 0x6d, 0x68, 0xaf,
	0x45, 0x3e, 0xc6, 0x8e, 0xad, 0x3f, 0x1a, 0x67, 0x6e, 0x8a, 0x5d, 0x7b, 0x19, 0x56, 0x62, 0x84,
	0xa8, 0xbb, 0x35, 0x33, 0xc9, 0x86, 0x24, 0x80, 0x4c, 0xac, 0x10, 0xd8, 0xae, 0x3b, 0xfb, 0x6f,
	0x7c, 0x0e, 0xab, 0x6a, 0xbc, 0x4f, 0x44, 0x30, 0x75, 0x10, 0x69, 0x3a, 0x51, 0xa8, 0x1f, 0xc1,
	0xca, 0x4e, 0x4f, 0x34, 0x86, 0xad, 0x8f, 0xd9, 0x63, 0x8c, 0xb4, 0x08, 0xc9, 0x28, 0x28, 0x1d,
	0xe4, 0x78, 0x7d, 0x26, 0x8f, 0x14, 0x60, 0x79, 0x30, 0x6c, 0x39, 0x6a, 0x58, 0x84, 0x54, 0xb2,
	0x34, 0x40, 0x67, 0xd6, 0x9f, 0x0c, 0x20, 0x36, 0xeb, 0x78, 0x42, 0xb2, 0x60, 0xfb, 0x93, 0xe6,
	0x01, 0x72, 0xc4, 0x4f, 0xc9, 0xf7, 0x21, 0x73, 0x18, 0xf0, 0x7e, 0x9c, 0xb6, 0x76, 0xcc, 0xaf,
	0xbf, 0xb8, 0x91, 0xd7, 0x31, 0x6a, 0xd6, 0x6a, 0xca, 0xc0, 0xf3, 0x3b, 0x76, 0x5a, 0x69, 0x47,
	0x44, 0xf6, 0x1e, 0x24, 0xd4, 0x2d, 0xc2, 0x00, 0xd2, 0x5b, 0xe6, 0xf4, 0x61, 0x45, 0x24, 0x69,
	0xa3, 0xd6, 0x9d, 0xdb, 0x9f, 0x7e, 0x5e, 0x9e, 0xfb, 0xd7, 0xe7, 0xe5, 0xb9, 0x27, 0x2f, 0x9f,
	0x6d, 0xa6, 0x3f, 0x38, 0xf5, 0x73, 0xfc, 0xf2, 0xd9, 0xe6, 0xa5, 0x89, 0xe2, 0x1d, 0x4c, 0x70,
	0xa6, 0xb2, 0xb7, 0x2e, 0x42, 0x61, 0x26, 0xf4, 0x90, 0xde, 0xac, 0x5f, 0x19, 0x90, 0x9d, 0xc0,
	0xbe, 0x71, 0x4a, 0xd7, 0x21, 0xe1, 0xf9, 0x87, 0x5c, 0xa7, 0x54, 0x38, 0x67, 0xe2, 0xdb, 0xa8,
	0x74, 0x27, 0x37, 0x9d, 0x89, 0xf5, 0x5b, 0x03, 0xd6, 0x63, 0xe1, 0x84, 0x61, 0xfe, 0x5f, 0x63,
	0xfa, 0xb5, 0x01, 0xb9, 0x5d, 0xf6, 0x16, 0x15, 0xe9, 0x33, 0x03, 0x2e, 0x4c, 0x05, 0xf4, 0x16,
	0x94, 0xe9, 0x0f, 0xf3, 0x90, 0xd5, 0x57, 0x6b, 0xd8, 0xc3, 0x7b, 0xf7, 0x26, 0xef, 0xa6, 0xf7,
	0x80, 0xc4, 0x47, 0x32, 0x4e, 0xf3, 0xb0, 0x33, 0x73, 0x93, 0x03, 0xf9, 0x23, 0x35, 0xd9, 0x2f,
	0xc3, 0x4a, 0x4c, 0x5b, 0xf7, 0x6a, 0x66, 0x52, 0x51, 0x29, 0xb5, 0x7a, 0x02, 0xa7, 0x07, 0x95,
	0xc3, 0x80, 0xe1, 0x23, 0x20, 0x63, 0x67, 0x5a, 0x3d, 0xd1, 0x8c, 0x64, 0xe7, 0xbf, 0x3f, 0x16,
	0xcf, 0x7f, 0x7f, 0x4c, 0xbc, 0x2b, 0x96, 0x62, 0xef, 0x8a, 0xeb, 0xb0, 0x38, 0xe8, 0x52, 0xc1,
	0x70, 0xba, 0x67, 0xb7, 0x2e, 0x4c, 0x97, 0xb0, 0xa1, 0x40, 0x3b, 0xd4, 0xb1, 0xfe, 0x6c, 0xc0,
	0x7a, 0x73, 0xd8, 0xea, 0x7b, 0xf2, 0xb4, 0x6a, 0xdf, 0xf8, 0x66, 0x6d, 0xc5, 0xce, 0xb0, 0x74,
	0x16, 0xa3, 0x9c, 0x9e, 0x8f, 0x3e, 0xca, 0xef, 0xbe, 0x8a, 0x57, 0x0a, 0x13, 0xbc, 0x12, 0x4d,
	0x03, 0xe4, 0x94, 0x22, 0x98, 0xb3, 0xd1, 0x87, 0x95, 0xdf, 0xfc, 0xa5, 0x01, 0x8b, 0x98, 0x2b,
	0xb9, 0x0e, 0x6b, 0x8d, 0x8f, 0xb6, 0x9b, 0x7b, 0xce, 0x83, 0xfb, 0xcd, 0xc6, 0xde, 0xdd, 0xfa,
	0x07, 0xf5, 0xbd, 0xdd, 0xdc, 0x5c, 0x31, 0x7f, 0xfc, 0xb4, 0x92, 0x43, 0x8d, 0x07, 0xbe, 0x18,
	0xb0, 0xb6, 0xfa, 0xcf, 0x98, 0xab, 0x0e, 0x2c, 0x54, 0x6e, 0xd8, 0x7b, 0x8d, 0x6d, 0x7b, 0x2f,
	0x67, 0x14, 0x73, 0xc7, 0x4f, 0x2b, 0x19, 0x54, 0x6c, 0x04, 0x6c, 0x40, 0x03, 0x46, 0xae, 0xc2,
	0x6a, 0xa8, 0xb4, 0xbb, 0xef, 0xdc, 0xdd, 0xbf, 0x77, 0xaf, 0x7e, 0x90, 0x9b, 0x2f, 0xae, 0x1d,
	0x3f, 0xad, 0xac, 0xa0, 0xda, 0x2e, 0xbf, 0xcb, 0xfb, 0x7d, 0x4f, 0x16, 0x13, 0x9f, 0xfe, 0xae,
	0x34, 0xb7, 0xf5, 0xfb, 0x04, 0x2c, 0xdc, 0x13, 0x1d, 0xf2, 0x33, 0x48, 0x4f, 0xf4, 0x0b, 0x99,
	0x29, 0x4c, 0xbc, 0xbb, 0x8b, 0x97, 0x5f, 0x89, 0x6b, 0xea, 0xbc, 0xfa, 0xe4, 0xaf, 0xff, 0xfc,
	0x6c, 0xbe, 0x62, 0x95, 0x6a, 0x33, 0x3f, 0x4a, 0xd4, 0x26, 0x37, 0x7b, 0x62, 0xc0, 0x4a, 0xac,
	0x5d, 0x49, 0x65, 0xda, 0xfd, 0x34, 0xbd, 0x14, 0xaf, 0xbc, 0x46, 0x43, 0x87, 0xb0, 0x81, 0x21,
	0x58, 0x56, 0xe5, 0x8c, 0x10, 0xe2, 0x5b, 0x1e, 0x1b, 0xb0, 0x3a, 0x35, 0x03, 0x88, 0xf5, 0x8a,
	0x2c, 0xf5, 0x7c, 0x2b, 0xbe, 0xfb, 0x5a, 0x1d, 0x1d, 0xca, 0x26, 0x86, 0xf2, 0x1d, 0xcb, 0x7a,
	0x75, 0x35, 0x70, 0x63, 0xc5, 0xa8, 0xd3, 0x97, 0x87, 0xcc, 0xd4, 0xfc, 0x8c, 0xe6, 0x28, 0x6e,
	0xbc, 0x5e, 0x49, 0xc7, 0x73, 0x1d, 0xe3, 0xb9, 0x62, 0x5d, 0x3e, 0x23, 0x9e, 0x69, 0xa3, 0xe2,
	0xe2, 0x2f, 0x5e, 0x3e, 0xdb, 0x34, 0x76, 0x3e, 0xfc, 0xf2, 0xa4, 0x64, 0x7c, 0x75, 0x52, 0x32,
	0xfe, 0x71, 0x52, 0x32, 0x7e, 0xf3, 0xa2, 0x34, 0xf7, 0xd5, 0x8b, 0xd2, 0xdc, 0xdf, 0x5e, 0x94,
	0xe6, 0x7e, 0x7c, 0x63, 0xe2, 0xb5, 0xb2, 0x17, 0xfa, 0xbb, 0xcf, 0xe4, 0x43, 0x1e, 0x1c, 0x8d,
	0xdd, 0x3f, 0xc2, 0x0d, 0xf0, 0xe1, 0xd2, 0x5a, 0xc2, 0x5f, 0x82, 0xde, 0xff, 0x4f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0xdb, 0xbf, 0x57, 0x92, 0xaf, 0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// RegisterAVS registers a new AVS with corresponding operator.
	RegisterAVS(ctx context.Context, in *RegisterAVSReq, opts ...grpc.CallOption) (*RegisterAVSResponse, error)
	// DelegateAssetToOperator delegates asset to operator.
	DeRegisterAVS(ctx context.Context, in *DeRegisterAVSReq, opts ...grpc.CallOption) (*DeRegisterAVSResponse, error)
	// RegisterAVSTask registers a new task.
	RegisterAVSTask(ctx context.Context, in *RegisterAVSTaskReq, opts ...grpc.CallOption) (*RegisterAVSTaskResponse, error)
	// SubmitTaskResult operator submit task results .
	SubmitTaskResult(ctx context.Context, in *SubmitTaskResultReq, opts ...grpc.CallOption) (*SubmitTaskResultResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) RegisterAVS(ctx context.Context, in *RegisterAVSReq, opts ...grpc.CallOption) (*RegisterAVSResponse, error) {
	out := new(RegisterAVSResponse)
	err := c.cc.Invoke(ctx, "/exocore.avs.v1.Msg/RegisterAVS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeRegisterAVS(ctx context.Context, in *DeRegisterAVSReq, opts ...grpc.CallOption) (*DeRegisterAVSResponse, error) {
	out := new(DeRegisterAVSResponse)
	err := c.cc.Invoke(ctx, "/exocore.avs.v1.Msg/DeRegisterAVS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterAVSTask(ctx context.Context, in *RegisterAVSTaskReq, opts ...grpc.CallOption) (*RegisterAVSTaskResponse, error) {
	out := new(RegisterAVSTaskResponse)
	err := c.cc.Invoke(ctx, "/exocore.avs.v1.Msg/RegisterAVSTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitTaskResult(ctx context.Context, in *SubmitTaskResultReq, opts ...grpc.CallOption) (*SubmitTaskResultResponse, error) {
	out := new(SubmitTaskResultResponse)
	err := c.cc.Invoke(ctx, "/exocore.avs.v1.Msg/SubmitTaskResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// RegisterAVS registers a new AVS with corresponding operator.
	RegisterAVS(context.Context, *RegisterAVSReq) (*RegisterAVSResponse, error)
	// DelegateAssetToOperator delegates asset to operator.
	DeRegisterAVS(context.Context, *DeRegisterAVSReq) (*DeRegisterAVSResponse, error)
	// RegisterAVSTask registers a new task.
	RegisterAVSTask(context.Context, *RegisterAVSTaskReq) (*RegisterAVSTaskResponse, error)
	// SubmitTaskResult operator submit task results .
	SubmitTaskResult(context.Context, *SubmitTaskResultReq) (*SubmitTaskResultResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterAVS(ctx context.Context, req *RegisterAVSReq) (*RegisterAVSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterAVS not implemented")
}
func (*UnimplementedMsgServer) DeRegisterAVS(ctx context.Context, req *DeRegisterAVSReq) (*DeRegisterAVSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeRegisterAVS not implemented")
}
func (*UnimplementedMsgServer) RegisterAVSTask(ctx context.Context, req *RegisterAVSTaskReq) (*RegisterAVSTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterAVSTask not implemented")
}
func (*UnimplementedMsgServer) SubmitTaskResult(ctx context.Context, req *SubmitTaskResultReq) (*SubmitTaskResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTaskResult not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_RegisterAVS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterAVSReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterAVS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exocore.avs.v1.Msg/RegisterAVS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterAVS(ctx, req.(*RegisterAVSReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeRegisterAVS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeRegisterAVSReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeRegisterAVS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exocore.avs.v1.Msg/DeRegisterAVS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeRegisterAVS(ctx, req.(*DeRegisterAVSReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterAVSTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterAVSTaskReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterAVSTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exocore.avs.v1.Msg/RegisterAVSTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterAVSTask(ctx, req.(*RegisterAVSTaskReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitTaskResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitTaskResultReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitTaskResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exocore.avs.v1.Msg/SubmitTaskResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitTaskResult(ctx, req.(*SubmitTaskResultReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "exocore.avs.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterAVS",
			Handler:    _Msg_RegisterAVS_Handler,
		},
		{
			MethodName: "DeRegisterAVS",
			Handler:    _Msg_DeRegisterAVS_Handler,
		},
		{
			MethodName: "RegisterAVSTask",
			Handler:    _Msg_RegisterAVSTask_Handler,
		},
		{
			MethodName: "SubmitTaskResult",
			Handler:    _Msg_SubmitTaskResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "exocore/avs/v1/tx.proto",
}

func (m *AVSInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AVSInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AVSInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssetRewardAmountEpochBasis) > 0 {
		for k := range m.AssetRewardAmountEpochBasis {
			v := m.AssetRewardAmountEpochBasis[k]
			baseI := i
			i = encodeVarintTx(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTx(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTx(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	{
		size := m.AvsSlash.Size()
		i -= size
		if _, err := m.AvsSlash.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	{
		size := m.AvsReward.Size()
		i -= size
		if _, err := m.AvsReward.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x7a
	}
	if m.StartingEpoch != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.StartingEpoch))
		i--
		dAtA[i] = 0x70
	}
	if m.MinTotalStakeAmount != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MinTotalStakeAmount))
		i--
		dAtA[i] = 0x68
	}
	if m.MinOptInOperators != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MinOptInOperators))
		i--
		dAtA[i] = 0x60
	}
	if len(m.EpochIdentifier) > 0 {
		i -= len(m.EpochIdentifier)
		copy(dAtA[i:], m.EpochIdentifier)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EpochIdentifier)))
		i--
		dAtA[i] = 0x5a
	}
	if m.MinSelfDelegation != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MinSelfDelegation))
		i--
		dAtA[i] = 0x50
	}
	if m.AvsUnbondingPeriod != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.AvsUnbondingPeriod))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AssetIDs) > 0 {
		for iNdEx := len(m.AssetIDs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AssetIDs[iNdEx])
			copy(dAtA[i:], m.AssetIDs[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AssetIDs[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.AvsOwnerAddress) > 0 {
		for iNdEx := len(m.AvsOwnerAddress) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AvsOwnerAddress[iNdEx])
			copy(dAtA[i:], m.AvsOwnerAddress[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AvsOwnerAddress[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.RewardAddr) > 0 {
		i -= len(m.RewardAddr)
		copy(dAtA[i:], m.RewardAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RewardAddr)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SlashAddr) > 0 {
		i -= len(m.SlashAddr)
		copy(dAtA[i:], m.SlashAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SlashAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TaskAddr) > 0 {
		i -= len(m.TaskAddr)
		copy(dAtA[i:], m.TaskAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TaskAddr)))
		i--
		dAtA[i] = 0x22
	}
	if m.MinStakeAmount != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MinStakeAmount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AvsAddress) > 0 {
		i -= len(m.AvsAddress)
		copy(dAtA[i:], m.AvsAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AvsAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OperatorStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperatorStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofData) > 0 {
		i -= len(m.ProofData)
		copy(dAtA[i:], m.ProofData)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProofData)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OperatorAddress) > 0 {
		i -= len(m.OperatorAddress)
		copy(dAtA[i:], m.OperatorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OperatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardSlashProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardSlashProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardSlashProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperatorStatus) > 0 {
		for iNdEx := len(m.OperatorStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperatorStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.AvsAddress) > 0 {
		i -= len(m.AvsAddress)
		copy(dAtA[i:], m.AvsAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AvsAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Aggregator) > 0 {
		i -= len(m.Aggregator)
		copy(dAtA[i:], m.Aggregator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Aggregator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TaskContractAddress) > 0 {
		i -= len(m.TaskContractAddress)
		copy(dAtA[i:], m.TaskContractAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TaskContractAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OperatorActivePower != nil {
		{
			size, err := m.OperatorActivePower.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	{
		size := m.TaskTotalPower.Size()
		i -= size
		if _, err := m.TaskTotalPower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	if len(m.ErrSignedOperators) > 0 {
		for iNdEx := len(m.ErrSignedOperators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ErrSignedOperators[iNdEx])
			copy(dAtA[i:], m.ErrSignedOperators[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.ErrSignedOperators[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.NoSignedOperators) > 0 {
		for iNdEx := len(m.NoSignedOperators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NoSignedOperators[iNdEx])
			copy(dAtA[i:], m.NoSignedOperators[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.NoSignedOperators[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.SignedOperators) > 0 {
		for iNdEx := len(m.SignedOperators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SignedOperators[iNdEx])
			copy(dAtA[i:], m.SignedOperators[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.SignedOperators[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.OptInOperators) > 0 {
		for iNdEx := len(m.OptInOperators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.OptInOperators[iNdEx])
			copy(dAtA[i:], m.OptInOperators[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.OptInOperators[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.ActualThreshold != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ActualThreshold))
		i--
		dAtA[i] = 0x50
	}
	if m.StartingEpoch != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.StartingEpoch))
		i--
		dAtA[i] = 0x48
	}
	if m.ThresholdPercentage != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ThresholdPercentage))
		i--
		dAtA[i] = 0x40
	}
	if m.TaskChallengePeriod != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TaskChallengePeriod))
		i--
		dAtA[i] = 0x38
	}
	if m.TaskStatisticalPeriod != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TaskStatisticalPeriod))
		i--
		dAtA[i] = 0x30
	}
	if m.TaskResponsePeriod != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TaskResponsePeriod))
		i--
		dAtA[i] = 0x28
	}
	if m.TaskId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TaskId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TaskContractAddress) > 0 {
		i -= len(m.TaskContractAddress)
		copy(dAtA[i:], m.TaskContractAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TaskContractAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OperatorActivePowerList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorActivePowerList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperatorActivePowerList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperatorPowerList) > 0 {
		for iNdEx := len(m.OperatorPowerList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperatorPowerList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OperatorActivePowerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorActivePowerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperatorActivePowerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.SelfActivePower.Size()
		i -= size
		if _, err := m.SelfActivePower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.OperatorAddr) > 0 {
		i -= len(m.OperatorAddr)
		copy(dAtA[i:], m.OperatorAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OperatorAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlsPubKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlsPubKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlsPubKeyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterAVSTaskReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterAVSTaskReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterAVSTaskReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Task != nil {
		{
			size, err := m.Task.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterAVSTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterAVSTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterAVSTaskResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RegisterAVSReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterAVSReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterAVSReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterAVSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterAVSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterAVSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeRegisterAVSReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeRegisterAVSReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeRegisterAVSReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeRegisterAVSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeRegisterAVSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeRegisterAVSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TaskResultInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskResultInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TaskResultInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Phase != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x38
	}
	if m.TaskId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TaskId))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TaskContractAddress) > 0 {
		i -= len(m.TaskContractAddress)
		copy(dAtA[i:], m.TaskContractAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TaskContractAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.BlsSignature) > 0 {
		i -= len(m.BlsSignature)
		copy(dAtA[i:], m.BlsSignature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BlsSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TaskResponse) > 0 {
		i -= len(m.TaskResponse)
		copy(dAtA[i:], m.TaskResponse)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TaskResponse)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TaskResponseHash) > 0 {
		i -= len(m.TaskResponseHash)
		copy(dAtA[i:], m.TaskResponseHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TaskResponseHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OperatorAddress) > 0 {
		i -= len(m.OperatorAddress)
		copy(dAtA[i:], m.OperatorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OperatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubmitTaskResultReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitTaskResultReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubmitTaskResultReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubmitTaskResultResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitTaskResultResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubmitTaskResultResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AVSInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AvsAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinStakeAmount != 0 {
		n += 1 + sovTx(uint64(m.MinStakeAmount))
	}
	l = len(m.TaskAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SlashAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RewardAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AvsOwnerAddress) > 0 {
		for _, s := range m.AvsOwnerAddress {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.AssetIDs) > 0 {
		for _, s := range m.AssetIDs {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.AvsUnbondingPeriod != 0 {
		n += 1 + sovTx(uint64(m.AvsUnbondingPeriod))
	}
	if m.MinSelfDelegation != 0 {
		n += 1 + sovTx(uint64(m.MinSelfDelegation))
	}
	l = len(m.EpochIdentifier)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinOptInOperators != 0 {
		n += 1 + sovTx(uint64(m.MinOptInOperators))
	}
	if m.MinTotalStakeAmount != 0 {
		n += 1 + sovTx(uint64(m.MinTotalStakeAmount))
	}
	if m.StartingEpoch != 0 {
		n += 1 + sovTx(uint64(m.StartingEpoch))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.AvsReward.Size()
	n += 2 + l + sovTx(uint64(l))
	l = m.AvsSlash.Size()
	n += 2 + l + sovTx(uint64(l))
	if len(m.AssetRewardAmountEpochBasis) > 0 {
		for k, v := range m.AssetRewardAmountEpochBasis {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTx(uint64(len(k))) + 1 + sovTx(uint64(v))
			n += mapEntrySize + 2 + sovTx(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *OperatorStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OperatorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ProofData)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *RewardSlashProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TaskContractAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Aggregator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AvsAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.OperatorStatus) > 0 {
		for _, e := range m.OperatorStatus {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *TaskInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TaskContractAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TaskId != 0 {
		n += 1 + sovTx(uint64(m.TaskId))
	}
	if m.TaskResponsePeriod != 0 {
		n += 1 + sovTx(uint64(m.TaskResponsePeriod))
	}
	if m.TaskStatisticalPeriod != 0 {
		n += 1 + sovTx(uint64(m.TaskStatisticalPeriod))
	}
	if m.TaskChallengePeriod != 0 {
		n += 1 + sovTx(uint64(m.TaskChallengePeriod))
	}
	if m.ThresholdPercentage != 0 {
		n += 1 + sovTx(uint64(m.ThresholdPercentage))
	}
	if m.StartingEpoch != 0 {
		n += 1 + sovTx(uint64(m.StartingEpoch))
	}
	if m.ActualThreshold != 0 {
		n += 1 + sovTx(uint64(m.ActualThreshold))
	}
	if len(m.OptInOperators) > 0 {
		for _, s := range m.OptInOperators {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.SignedOperators) > 0 {
		for _, s := range m.SignedOperators {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.NoSignedOperators) > 0 {
		for _, s := range m.NoSignedOperators {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.ErrSignedOperators) > 0 {
		for _, s := range m.ErrSignedOperators {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = m.TaskTotalPower.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.OperatorActivePower != nil {
		l = m.OperatorActivePower.Size()
		n += 2 + l + sovTx(uint64(l))
	}
	return n
}

func (m *OperatorActivePowerList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OperatorPowerList) > 0 {
		for _, e := range m.OperatorPowerList {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *OperatorActivePowerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OperatorAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.SelfActivePower.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *BlsPubKeyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *RegisterAVSTaskReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *RegisterAVSTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RegisterAVSReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *RegisterAVSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *DeRegisterAVSReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *DeRegisterAVSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *TaskResultInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OperatorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TaskResponseHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TaskResponse)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BlsSignature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TaskContractAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TaskId != 0 {
		n += 1 + sovTx(uint64(m.TaskId))
	}
	if m.Phase != 0 {
		n += 1 + sovTx(uint64(m.Phase))
	}
	return n
}

func (m *SubmitTaskResultReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *SubmitTaskResultResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AVSInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AVSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AVSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvsAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvsAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinStakeAmount", wireType)
			}
			m.MinStakeAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinStakeAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvsOwnerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvsOwnerAddress = append(m.AvsOwnerAddress, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetIDs = append(m.AssetIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvsUnbondingPeriod", wireType)
			}
			m.AvsUnbondingPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvsUnbondingPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSelfDelegation", wireType)
			}
			m.MinSelfDelegation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSelfDelegation |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinOptInOperators", wireType)
			}
			m.MinOptInOperators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinOptInOperators |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTotalStakeAmount", wireType)
			}
			m.MinTotalStakeAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTotalStakeAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingEpoch", wireType)
			}
			m.StartingEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartingEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvsReward", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvsReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvsSlash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AvsSlash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetRewardAmountEpochBasis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AssetRewardAmountEpochBasis == nil {
				m.AssetRewardAmountEpochBasis = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTx
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTx
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTx(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTx
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AssetRewardAmountEpochBasis[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofData = append(m.ProofData[:0], dAtA[iNdEx:postIndex]...)
			if m.ProofData == nil {
				m.ProofData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardSlashProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardSlashProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardSlashProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aggregator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aggregator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvsAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvsAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorStatus = append(m.OperatorStatus, &OperatorStatus{})
			if err := m.OperatorStatus[len(m.OperatorStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskResponsePeriod", wireType)
			}
			m.TaskResponsePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskResponsePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskStatisticalPeriod", wireType)
			}
			m.TaskStatisticalPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskStatisticalPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskChallengePeriod", wireType)
			}
			m.TaskChallengePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskChallengePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdPercentage", wireType)
			}
			m.ThresholdPercentage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThresholdPercentage |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingEpoch", wireType)
			}
			m.StartingEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartingEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualThreshold", wireType)
			}
			m.ActualThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualThreshold |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptInOperators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OptInOperators = append(m.OptInOperators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedOperators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedOperators = append(m.SignedOperators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoSignedOperators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NoSignedOperators = append(m.NoSignedOperators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrSignedOperators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrSignedOperators = append(m.ErrSignedOperators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskTotalPower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TaskTotalPower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorActivePower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OperatorActivePower == nil {
				m.OperatorActivePower = &OperatorActivePowerList{}
			}
			if err := m.OperatorActivePower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorActivePowerList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorActivePowerList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorActivePowerList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorPowerList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorPowerList = append(m.OperatorPowerList, &OperatorActivePowerInfo{})
			if err := m.OperatorPowerList[len(m.OperatorPowerList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorActivePowerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorActivePowerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorActivePowerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfActivePower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SelfActivePower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlsPubKeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlsPubKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlsPubKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterAVSTaskReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterAVSTaskReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterAVSTaskReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &TaskInfo{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterAVSTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterAVSTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterAVSTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterAVSReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterAVSReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterAVSReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &AVSInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterAVSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterAVSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterAVSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &AVSInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeRegisterAVSReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeRegisterAVSReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeRegisterAVSReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &AVSInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeRegisterAVSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeRegisterAVSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeRegisterAVSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &AVSInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskResultInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskResultInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskResultInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskResponseHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskResponseHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskResponse", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskResponse = append(m.TaskResponse[:0], dAtA[iNdEx:postIndex]...)
			if m.TaskResponse == nil {
				m.TaskResponse = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlsSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlsSignature = append(m.BlsSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.BlsSignature == nil {
				m.BlsSignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskContractAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskContractAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= Phase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitTaskResultReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitTaskResultReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitTaskResultReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &TaskResultInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitTaskResultResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitTaskResultResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitTaskResultResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)

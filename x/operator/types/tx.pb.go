// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: exocore/operator/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	types "github.com/cosmos/cosmos-sdk/x/staking/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SlashType represents different slash type
type SlashType int32

const (
	// SLASH_TYPE__UNSPECIFIED represents the unspecified slash type
	SlashType_SLASH_TYPE_UNSPECIFIED SlashType = 0
	// SLASH_TYPE_INSTANT_SLASH represents the slash events that will be handled instantly after occurring
	// so the slash will reduce the amount of related operator's assets pool.
	SlashType_SLASH_TYPE_INSTANT_SLASH SlashType = 1
	// NoInstantaneousSlash indicates that the slash event will be processed after a certain
	// period of time, thus requiring a reduction in the share of the corresponding staker.
	SlashType_SLASH_TYPE_NO_INSTANTANEOUS_SLASH SlashType = 2
)

var SlashType_name = map[int32]string{
	0: "SLASH_TYPE_UNSPECIFIED",
	1: "SLASH_TYPE_INSTANT_SLASH",
	2: "SLASH_TYPE_NO_INSTANTANEOUS_SLASH",
}

var SlashType_value = map[string]int32{
	"SLASH_TYPE_UNSPECIFIED":            0,
	"SLASH_TYPE_INSTANT_SLASH":          1,
	"SLASH_TYPE_NO_INSTANTANEOUS_SLASH": 2,
}

func (x SlashType) String() string {
	return proto.EnumName(SlashType_name, int32(x))
}

func (SlashType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{0}
}

// DecValueField is a field that holds a value of sdk.LegacyDec type.
type DecValueField struct {
	// amount is the USD value of the asset, as an sdk.LegacyDec.
	Amount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *DecValueField) Reset()         { *m = DecValueField{} }
func (m *DecValueField) String() string { return proto.CompactTextString(m) }
func (*DecValueField) ProtoMessage()    {}
func (*DecValueField) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{0}
}
func (m *DecValueField) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecValueField) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecValueField.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecValueField) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecValueField.Merge(m, src)
}
func (m *DecValueField) XXX_Size() int {
	return m.Size()
}
func (m *DecValueField) XXX_DiscardUnknown() {
	xxx_messageInfo_DecValueField.DiscardUnknown(m)
}

var xxx_messageInfo_DecValueField proto.InternalMessageInfo

// OperatorOptedUSDValue records the self and total opted-in USD value for the specified operator and AVS
type OperatorOptedUSDValue struct {
	// self_usd_value is the USD value owned by the operator itself.
	SelfUSDValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=self_usd_value,json=selfUsdValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"self_usd_value"`
	// total_usd_value is the total opted-in USD value for the specified operator and AVS
	TotalUSDValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=total_usd_value,json=totalUsdValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"total_usd_value"`
	// active_usd_value is the active opted-in USD value for the specified operator and AVS
	// this field will be zero if the operator's self staking isn't sufficient. Of course, it will
	// be equal to total_usd_value if the operator's self staking meets the AVS requirement.
	ActiveUSDValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=active_usd_value,json=activeUsdValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"active_usd_value"`
}

func (m *OperatorOptedUSDValue) Reset()         { *m = OperatorOptedUSDValue{} }
func (m *OperatorOptedUSDValue) String() string { return proto.CompactTextString(m) }
func (*OperatorOptedUSDValue) ProtoMessage()    {}
func (*OperatorOptedUSDValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{1}
}
func (m *OperatorOptedUSDValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorOptedUSDValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorOptedUSDValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorOptedUSDValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorOptedUSDValue.Merge(m, src)
}
func (m *OperatorOptedUSDValue) XXX_Size() int {
	return m.Size()
}
func (m *OperatorOptedUSDValue) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorOptedUSDValue.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorOptedUSDValue proto.InternalMessageInfo

// OperatorVotingPower represents the voting power for the specified operator address
type OperatorVotingPower struct {
	// operator_addr is the operator address,its type should be a sdk.AccAddress
	OperatorAddr string `protobuf:"bytes,1,opt,name=operator_addr,json=operatorAddr,proto3" json:"operator_addr,omitempty"`
	// voting_power is the active voting power for the above operator address
	VotingPower github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=voting_power,json=votingPower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"voting_power"`
}

func (m *OperatorVotingPower) Reset()         { *m = OperatorVotingPower{} }
func (m *OperatorVotingPower) String() string { return proto.CompactTextString(m) }
func (*OperatorVotingPower) ProtoMessage()    {}
func (*OperatorVotingPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{2}
}
func (m *OperatorVotingPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorVotingPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorVotingPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorVotingPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorVotingPower.Merge(m, src)
}
func (m *OperatorVotingPower) XXX_Size() int {
	return m.Size()
}
func (m *OperatorVotingPower) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorVotingPower.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorVotingPower proto.InternalMessageInfo

func (m *OperatorVotingPower) GetOperatorAddr() string {
	if m != nil {
		return m.OperatorAddr
	}
	return ""
}

// VotingPowerSnapshot records historical voting power for AVSs at specific epochs
// or after slashing events.These snapshots are created at the end of each epoch and
// when slashing occurs, enabling historical queries of operator voting power at
// specific points in time.
type VotingPowerSnapshot struct {
	// total_voting_power is the total voting power of specified AVS
	TotalVotingPower github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=total_voting_power,json=totalVotingPower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"total_voting_power"`
	// operator_voting_powers records the active voting power of all operators
	// for the specified AVS
	OperatorVotingPowers []*OperatorVotingPower `protobuf:"bytes,2,rep,name=operator_voting_powers,json=operatorVotingPowers,proto3" json:"operator_voting_powers,omitempty"`
	// last_changed_height is used to indicate the height of most recent change when
	// the operator_voting_powers is nil, which can help to fall back to the correct epoch height.
	LastChangedHeight int64 `protobuf:"varint,3,opt,name=last_changed_height,json=lastChangedHeight,proto3" json:"last_changed_height,omitempty"`
	// epoch_identifier record the epoch info
	EpochIdentifier string `protobuf:"bytes,4,opt,name=epoch_identifier,json=epochIdentifier,proto3" json:"epoch_identifier,omitempty"`
	// epoch_number indicates which epoch this snapshot serve for
	EpochNumber int64 `protobuf:"varint,5,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number,omitempty"`
}

func (m *VotingPowerSnapshot) Reset()         { *m = VotingPowerSnapshot{} }
func (m *VotingPowerSnapshot) String() string { return proto.CompactTextString(m) }
func (*VotingPowerSnapshot) ProtoMessage()    {}
func (*VotingPowerSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{3}
}
func (m *VotingPowerSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VotingPowerSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VotingPowerSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VotingPowerSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VotingPowerSnapshot.Merge(m, src)
}
func (m *VotingPowerSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *VotingPowerSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_VotingPowerSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_VotingPowerSnapshot proto.InternalMessageInfo

func (m *VotingPowerSnapshot) GetOperatorVotingPowers() []*OperatorVotingPower {
	if m != nil {
		return m.OperatorVotingPowers
	}
	return nil
}

func (m *VotingPowerSnapshot) GetLastChangedHeight() int64 {
	if m != nil {
		return m.LastChangedHeight
	}
	return 0
}

func (m *VotingPowerSnapshot) GetEpochIdentifier() string {
	if m != nil {
		return m.EpochIdentifier
	}
	return ""
}

func (m *VotingPowerSnapshot) GetEpochNumber() int64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

// SnapshotHelper is used to record the helper information for voting power snapshot update
type SnapshotHelper struct {
	// last_changed_height indicates the height of the most recent change.
	// It is used to set the `last_changed_height` field in `VotingPowerSnapshot`.
	LastChangedHeight int64 `protobuf:"varint,1,opt,name=last_changed_height,json=lastChangedHeight,proto3" json:"last_changed_height,omitempty"`
	// has_opt_out is used to indicate whether there has been any opt-out operation from
	// the most recently saved snapshot to the current height. This is because,
	// when an opt-out operation occurs, the related AVS validator information changes,
	// and the snapshot needs to be updated.
	// Currently, a boolean variable is used instead of an operator list
	// because the snapshot is set by default to store all operator information related to AVS.
	// Therefore, as long as any operator has opted out, the snapshot needs to be updated.
	// If we later introduce a limit on the maximum number of validators in AVS,
	// similar to the MaxValidatorNumber in Dogfood, this may need to be changed to an operator list
	// to track all operators that have opted out, thereby assisting with the correct snapshot update.
	HasOptOut bool `protobuf:"varint,2,opt,name=has_opt_out,json=hasOptOut,proto3" json:"has_opt_out,omitempty"`
}

func (m *SnapshotHelper) Reset()         { *m = SnapshotHelper{} }
func (m *SnapshotHelper) String() string { return proto.CompactTextString(m) }
func (*SnapshotHelper) ProtoMessage()    {}
func (*SnapshotHelper) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{4}
}
func (m *SnapshotHelper) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotHelper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotHelper.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotHelper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotHelper.Merge(m, src)
}
func (m *SnapshotHelper) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotHelper) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotHelper.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotHelper proto.InternalMessageInfo

func (m *SnapshotHelper) GetLastChangedHeight() int64 {
	if m != nil {
		return m.LastChangedHeight
	}
	return 0
}

func (m *SnapshotHelper) GetHasOptOut() bool {
	if m != nil {
		return m.HasOptOut
	}
	return false
}

// ClientChainEarningAddrList is the list of client chain earning addresses.
// Because the reward token provide by the AVS might be located at different client chain, the operator need to
// provide the different client chain address to receive the token rewards.
type ClientChainEarningAddrList struct {
	// earning_info_list is the contents of ClientChainEarningAddrList.
	EarningInfoList []*ClientChainEarningAddrInfo `protobuf:"bytes,1,rep,name=earning_info_list,json=earningInfoList,proto3" json:"earning_info_list,omitempty"`
}

func (m *ClientChainEarningAddrList) Reset()         { *m = ClientChainEarningAddrList{} }
func (m *ClientChainEarningAddrList) String() string { return proto.CompactTextString(m) }
func (*ClientChainEarningAddrList) ProtoMessage()    {}
func (*ClientChainEarningAddrList) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{5}
}
func (m *ClientChainEarningAddrList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientChainEarningAddrList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientChainEarningAddrList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientChainEarningAddrList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientChainEarningAddrList.Merge(m, src)
}
func (m *ClientChainEarningAddrList) XXX_Size() int {
	return m.Size()
}
func (m *ClientChainEarningAddrList) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientChainEarningAddrList.DiscardUnknown(m)
}

var xxx_messageInfo_ClientChainEarningAddrList proto.InternalMessageInfo

func (m *ClientChainEarningAddrList) GetEarningInfoList() []*ClientChainEarningAddrInfo {
	if m != nil {
		return m.EarningInfoList
	}
	return nil
}

// ClientChainEarningAddrInfo is the client chain earning address info.
type ClientChainEarningAddrInfo struct {
	// lz_client_chain_id is the layer0 client chain id.
	LzClientChainID uint64 `protobuf:"varint,1,opt,name=lz_client_chain_id,json=lzClientChainId,proto3" json:"lz_client_chain_id,omitempty"`
	// client_chain_earning_addr is the client chain earning address.
	ClientChainEarningAddr string `protobuf:"bytes,2,opt,name=client_chain_earning_addr,json=clientChainEarningAddr,proto3" json:"client_chain_earning_addr,omitempty"`
}

func (m *ClientChainEarningAddrInfo) Reset()         { *m = ClientChainEarningAddrInfo{} }
func (m *ClientChainEarningAddrInfo) String() string { return proto.CompactTextString(m) }
func (*ClientChainEarningAddrInfo) ProtoMessage()    {}
func (*ClientChainEarningAddrInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{6}
}
func (m *ClientChainEarningAddrInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientChainEarningAddrInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientChainEarningAddrInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientChainEarningAddrInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientChainEarningAddrInfo.Merge(m, src)
}
func (m *ClientChainEarningAddrInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClientChainEarningAddrInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientChainEarningAddrInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClientChainEarningAddrInfo proto.InternalMessageInfo

func (m *ClientChainEarningAddrInfo) GetLzClientChainID() uint64 {
	if m != nil {
		return m.LzClientChainID
	}
	return 0
}

func (m *ClientChainEarningAddrInfo) GetClientChainEarningAddr() string {
	if m != nil {
		return m.ClientChainEarningAddr
	}
	return ""
}

// OperatorInfo is the operator info.
type OperatorInfo struct {
	// earnings_addr is the earnings address.
	EarningsAddr string `protobuf:"bytes,1,opt,name=earnings_addr,json=earningsAddr,proto3" json:"earnings_addr,omitempty"`
	// approve_addr is the approve address.
	ApproveAddr string `protobuf:"bytes,2,opt,name=approve_addr,json=approveAddr,proto3" json:"approve_addr,omitempty"`
	// operator_meta_info is the operator meta info.
	OperatorMetaInfo string `protobuf:"bytes,3,opt,name=operator_meta_info,json=operatorMetaInfo,proto3" json:"operator_meta_info,omitempty"`
	// client_chain_earning_addr_list is the client chain earning address list.
	ClientChainEarningsAddr *ClientChainEarningAddrList `protobuf:"bytes,4,opt,name=client_chain_earnings_addr,json=clientChainEarningsAddr,proto3" json:"client_chain_earnings_addr,omitempty"`
	// commission defines the commission parameters. it includes the time at which the commission
	// was last updated.
	Commission types.Commission `protobuf:"bytes,5,opt,name=commission,proto3" json:"commission"`
}

func (m *OperatorInfo) Reset()         { *m = OperatorInfo{} }
func (m *OperatorInfo) String() string { return proto.CompactTextString(m) }
func (*OperatorInfo) ProtoMessage()    {}
func (*OperatorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{7}
}
func (m *OperatorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorInfo.Merge(m, src)
}
func (m *OperatorInfo) XXX_Size() int {
	return m.Size()
}
func (m *OperatorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorInfo proto.InternalMessageInfo

func (m *OperatorInfo) GetEarningsAddr() string {
	if m != nil {
		return m.EarningsAddr
	}
	return ""
}

func (m *OperatorInfo) GetApproveAddr() string {
	if m != nil {
		return m.ApproveAddr
	}
	return ""
}

func (m *OperatorInfo) GetOperatorMetaInfo() string {
	if m != nil {
		return m.OperatorMetaInfo
	}
	return ""
}

func (m *OperatorInfo) GetClientChainEarningsAddr() *ClientChainEarningAddrList {
	if m != nil {
		return m.ClientChainEarningsAddr
	}
	return nil
}

func (m *OperatorInfo) GetCommission() types.Commission {
	if m != nil {
		return m.Commission
	}
	return types.Commission{}
}

// OptedInfo is the opted information about operator
type OptedInfo struct {
	// slash_contract is the slash contract address of AVS opted-in by the operator
	SlashContract string `protobuf:"bytes,1,opt,name=slash_contract,json=slashContract,proto3" json:"slash_contract,omitempty"`
	// opted_in_height is the exocore block height at which the operator opted in
	OptedInHeight uint64 `protobuf:"varint,2,opt,name=opted_in_height,json=optedInHeight,proto3" json:"opted_in_height,omitempty"`
	// opted_out_height is the exocore block height at which the operator opted out
	OptedOutHeight uint64 `protobuf:"varint,3,opt,name=opted_out_height,json=optedOutHeight,proto3" json:"opted_out_height,omitempty"`
	// jailed defined whether the operator has been jailed from bonded status or not.
	Jailed bool `protobuf:"varint,4,opt,name=jailed,proto3" json:"jailed,omitempty"`
}

func (m *OptedInfo) Reset()         { *m = OptedInfo{} }
func (m *OptedInfo) String() string { return proto.CompactTextString(m) }
func (*OptedInfo) ProtoMessage()    {}
func (*OptedInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{8}
}
func (m *OptedInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptedInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptedInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptedInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptedInfo.Merge(m, src)
}
func (m *OptedInfo) XXX_Size() int {
	return m.Size()
}
func (m *OptedInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OptedInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OptedInfo proto.InternalMessageInfo

func (m *OptedInfo) GetSlashContract() string {
	if m != nil {
		return m.SlashContract
	}
	return ""
}

func (m *OptedInfo) GetOptedInHeight() uint64 {
	if m != nil {
		return m.OptedInHeight
	}
	return 0
}

func (m *OptedInfo) GetOptedOutHeight() uint64 {
	if m != nil {
		return m.OptedOutHeight
	}
	return 0
}

func (m *OptedInfo) GetJailed() bool {
	if m != nil {
		return m.Jailed
	}
	return false
}

// OptedInAssetState is the state of opted-in asset
type OptedInAssetState struct {
	// amount of the opted-in asset
	Amount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,1,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount"`
	// value is the USD value of the opted-in asset
	Value github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=value,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"value"`
}

func (m *OptedInAssetState) Reset()         { *m = OptedInAssetState{} }
func (m *OptedInAssetState) String() string { return proto.CompactTextString(m) }
func (*OptedInAssetState) ProtoMessage()    {}
func (*OptedInAssetState) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{9}
}
func (m *OptedInAssetState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptedInAssetState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptedInAssetState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptedInAssetState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptedInAssetState.Merge(m, src)
}
func (m *OptedInAssetState) XXX_Size() int {
	return m.Size()
}
func (m *OptedInAssetState) XXX_DiscardUnknown() {
	xxx_messageInfo_OptedInAssetState.DiscardUnknown(m)
}

var xxx_messageInfo_OptedInAssetState proto.InternalMessageInfo

// SlashFromUndelegation records the slash detail from the undelegation
type SlashFromUndelegation struct {
	// staker_id is the staker id.
	StakerID string `protobuf:"bytes,1,opt,name=staker_id,json=stakerId,proto3" json:"staker_id,omitempty"`
	// asset_id is the asset id.
	AssetID string `protobuf:"bytes,2,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// amount is the slashed amount from the undelegation.
	Amount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount"`
}

func (m *SlashFromUndelegation) Reset()         { *m = SlashFromUndelegation{} }
func (m *SlashFromUndelegation) String() string { return proto.CompactTextString(m) }
func (*SlashFromUndelegation) ProtoMessage()    {}
func (*SlashFromUndelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{10}
}
func (m *SlashFromUndelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashFromUndelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashFromUndelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashFromUndelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashFromUndelegation.Merge(m, src)
}
func (m *SlashFromUndelegation) XXX_Size() int {
	return m.Size()
}
func (m *SlashFromUndelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashFromUndelegation.DiscardUnknown(m)
}

var xxx_messageInfo_SlashFromUndelegation proto.InternalMessageInfo

func (m *SlashFromUndelegation) GetStakerID() string {
	if m != nil {
		return m.StakerID
	}
	return ""
}

func (m *SlashFromUndelegation) GetAssetID() string {
	if m != nil {
		return m.AssetID
	}
	return ""
}

// SlashFromAssetsPool records the slash detail from the operator assets pool
type SlashFromAssetsPool struct {
	// asset_id is the asset id.
	AssetID string `protobuf:"bytes,1,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// amount is the slashed amount from the assets pool.
	Amount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount"`
}

func (m *SlashFromAssetsPool) Reset()         { *m = SlashFromAssetsPool{} }
func (m *SlashFromAssetsPool) String() string { return proto.CompactTextString(m) }
func (*SlashFromAssetsPool) ProtoMessage()    {}
func (*SlashFromAssetsPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{11}
}
func (m *SlashFromAssetsPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashFromAssetsPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashFromAssetsPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashFromAssetsPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashFromAssetsPool.Merge(m, src)
}
func (m *SlashFromAssetsPool) XXX_Size() int {
	return m.Size()
}
func (m *SlashFromAssetsPool) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashFromAssetsPool.DiscardUnknown(m)
}

var xxx_messageInfo_SlashFromAssetsPool proto.InternalMessageInfo

func (m *SlashFromAssetsPool) GetAssetID() string {
	if m != nil {
		return m.AssetID
	}
	return ""
}

// SlashExecutionInfo is the actual execution state for a slash event
type SlashExecutionInfo struct {
	// slash_proportion is the new calculated proportion when execute the slash
	SlashProportion github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=slash_proportion,json=slashProportion,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"slash_proportion"`
	// slash_value is the usd value of all slashed assets
	SlashValue github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=slash_value,json=slashValue,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"slash_value"`
	// SlashUndelegations records all slash info related to the undelegation
	SlashUndelegations []SlashFromUndelegation `protobuf:"bytes,3,rep,name=slash_undelegations,json=slashUndelegations,proto3" json:"slash_undelegations"`
	// SlashFromAssetsPool records all slash info related to the assets pool
	SlashAssetsPool []SlashFromAssetsPool `protobuf:"bytes,4,rep,name=slash_assets_pool,json=slashAssetsPool,proto3" json:"slash_assets_pool"`
	// undelegation_filter_height records the height before which undelegations are not slashed
	UndelegationFilterHeight int64 `protobuf:"varint,5,opt,name=undelegation_filter_height,json=undelegationFilterHeight,proto3" json:"undelegation_filter_height,omitempty"`
	// the historical voting power at the time of the slash event.
	HistoricalVotingPower int64 `protobuf:"varint,6,opt,name=historical_voting_power,json=historicalVotingPower,proto3" json:"historical_voting_power,omitempty"`
}

func (m *SlashExecutionInfo) Reset()         { *m = SlashExecutionInfo{} }
func (m *SlashExecutionInfo) String() string { return proto.CompactTextString(m) }
func (*SlashExecutionInfo) ProtoMessage()    {}
func (*SlashExecutionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{12}
}
func (m *SlashExecutionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashExecutionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashExecutionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashExecutionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashExecutionInfo.Merge(m, src)
}
func (m *SlashExecutionInfo) XXX_Size() int {
	return m.Size()
}
func (m *SlashExecutionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashExecutionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SlashExecutionInfo proto.InternalMessageInfo

func (m *SlashExecutionInfo) GetSlashUndelegations() []SlashFromUndelegation {
	if m != nil {
		return m.SlashUndelegations
	}
	return nil
}

func (m *SlashExecutionInfo) GetSlashAssetsPool() []SlashFromAssetsPool {
	if m != nil {
		return m.SlashAssetsPool
	}
	return nil
}

func (m *SlashExecutionInfo) GetUndelegationFilterHeight() int64 {
	if m != nil {
		return m.UndelegationFilterHeight
	}
	return 0
}

func (m *SlashExecutionInfo) GetHistoricalVotingPower() int64 {
	if m != nil {
		return m.HistoricalVotingPower
	}
	return 0
}

// OperatorSlashInfo is the slash info of operator
type OperatorSlashInfo struct {
	// slash_contract is the address of slash contract
	SlashContract string `protobuf:"bytes,1,opt,name=slash_contract,json=slashContract,proto3" json:"slash_contract,omitempty"`
	// submitted_height is the exocore block height at which the slash event is submitted
	SubmittedHeight int64 `protobuf:"varint,2,opt,name=submitted_height,json=submittedHeight,proto3" json:"submitted_height,omitempty"`
	// event_height is the exocore block height at which the slash event occurs
	EventHeight int64 `protobuf:"varint,3,opt,name=event_height,json=eventHeight,proto3" json:"event_height,omitempty"`
	// is_vetoed is a flag to indicate if this slash is vetoed
	IsVetoed bool `protobuf:"varint,4,opt,name=is_vetoed,json=isVetoed,proto3" json:"is_vetoed,omitempty"`
	// slash_proportion is the proportion of assets that need to be slashed
	SlashProportion github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=slash_proportion,json=slashProportion,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"slash_proportion"`
	// slash_type indicates the slash type of specified AVS.
	SlashType uint32 `protobuf:"varint,6,opt,name=slash_type,json=slashType,proto3" json:"slash_type,omitempty"`
	// SlashExecutionInfo stores the slashed execution information
	ExecutionInfo *SlashExecutionInfo `protobuf:"bytes,7,opt,name=execution_info,json=executionInfo,proto3" json:"execution_info,omitempty"`
}

func (m *OperatorSlashInfo) Reset()         { *m = OperatorSlashInfo{} }
func (m *OperatorSlashInfo) String() string { return proto.CompactTextString(m) }
func (*OperatorSlashInfo) ProtoMessage()    {}
func (*OperatorSlashInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{13}
}
func (m *OperatorSlashInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperatorSlashInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperatorSlashInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OperatorSlashInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorSlashInfo.Merge(m, src)
}
func (m *OperatorSlashInfo) XXX_Size() int {
	return m.Size()
}
func (m *OperatorSlashInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorSlashInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorSlashInfo proto.InternalMessageInfo

func (m *OperatorSlashInfo) GetSlashContract() string {
	if m != nil {
		return m.SlashContract
	}
	return ""
}

func (m *OperatorSlashInfo) GetSubmittedHeight() int64 {
	if m != nil {
		return m.SubmittedHeight
	}
	return 0
}

func (m *OperatorSlashInfo) GetEventHeight() int64 {
	if m != nil {
		return m.EventHeight
	}
	return 0
}

func (m *OperatorSlashInfo) GetIsVetoed() bool {
	if m != nil {
		return m.IsVetoed
	}
	return false
}

func (m *OperatorSlashInfo) GetSlashType() uint32 {
	if m != nil {
		return m.SlashType
	}
	return 0
}

func (m *OperatorSlashInfo) GetExecutionInfo() *SlashExecutionInfo {
	if m != nil {
		return m.ExecutionInfo
	}
	return nil
}

// RegisterOperatorReq is the request to register a new operator.
type RegisterOperatorReq struct {
	// from_address is the address of the operator (sdk.AccAddress).
	FromAddress string `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	// info is the operator info.
	Info *OperatorInfo `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *RegisterOperatorReq) Reset()         { *m = RegisterOperatorReq{} }
func (m *RegisterOperatorReq) String() string { return proto.CompactTextString(m) }
func (*RegisterOperatorReq) ProtoMessage()    {}
func (*RegisterOperatorReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{14}
}
func (m *RegisterOperatorReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterOperatorReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterOperatorReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterOperatorReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterOperatorReq.Merge(m, src)
}
func (m *RegisterOperatorReq) XXX_Size() int {
	return m.Size()
}
func (m *RegisterOperatorReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterOperatorReq.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterOperatorReq proto.InternalMessageInfo

// RegisterOperatorResponse is the response to a register operator request.
type RegisterOperatorResponse struct {
}

func (m *RegisterOperatorResponse) Reset()         { *m = RegisterOperatorResponse{} }
func (m *RegisterOperatorResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterOperatorResponse) ProtoMessage()    {}
func (*RegisterOperatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{15}
}
func (m *RegisterOperatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterOperatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterOperatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterOperatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterOperatorResponse.Merge(m, src)
}
func (m *RegisterOperatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegisterOperatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterOperatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterOperatorResponse proto.InternalMessageInfo

// OptIntoAVSReq is the request to opt into an AVS.
type OptIntoAVSReq struct {
	// from_address is the address of the operator (sdk.AccAddress).
	FromAddress string `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	// avs_address is the address of the AVS.
	AvsAddress string `protobuf:"bytes,2,opt,name=avs_address,json=avsAddress,proto3" json:"avs_address,omitempty"`
	// public_key_json is an optional parameter to provide the consensus key.
	// the key is provided in the JSON format and not the hex format.
	// TODO: allow providing a BLS key here, depending on the AVS.
	PublicKeyJSON string `protobuf:"bytes,3,opt,name=public_key_json,json=publicKeyJson,proto3" json:"public_key_json,omitempty"`
}

func (m *OptIntoAVSReq) Reset()         { *m = OptIntoAVSReq{} }
func (m *OptIntoAVSReq) String() string { return proto.CompactTextString(m) }
func (*OptIntoAVSReq) ProtoMessage()    {}
func (*OptIntoAVSReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{16}
}
func (m *OptIntoAVSReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptIntoAVSReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptIntoAVSReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptIntoAVSReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptIntoAVSReq.Merge(m, src)
}
func (m *OptIntoAVSReq) XXX_Size() int {
	return m.Size()
}
func (m *OptIntoAVSReq) XXX_DiscardUnknown() {
	xxx_messageInfo_OptIntoAVSReq.DiscardUnknown(m)
}

var xxx_messageInfo_OptIntoAVSReq proto.InternalMessageInfo

// OptIntoAVSResponse is the response to a opt into an AVS request.
type OptIntoAVSResponse struct {
}

func (m *OptIntoAVSResponse) Reset()         { *m = OptIntoAVSResponse{} }
func (m *OptIntoAVSResponse) String() string { return proto.CompactTextString(m) }
func (*OptIntoAVSResponse) ProtoMessage()    {}
func (*OptIntoAVSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{17}
}
func (m *OptIntoAVSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptIntoAVSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptIntoAVSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptIntoAVSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptIntoAVSResponse.Merge(m, src)
}
func (m *OptIntoAVSResponse) XXX_Size() int {
	return m.Size()
}
func (m *OptIntoAVSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OptIntoAVSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OptIntoAVSResponse proto.InternalMessageInfo

// OptOutOfAVSReq is the request to opt out from an AVS.
type OptOutOfAVSReq struct {
	// from_address is the address of the operator (sdk.AccAddress).
	FromAddress string `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`
	// avs_address is the address of the AVS.
	AvsAddress string `protobuf:"bytes,2,opt,name=avs_address,json=avsAddress,proto3" json:"avs_address,omitempty"`
}

func (m *OptOutOfAVSReq) Reset()         { *m = OptOutOfAVSReq{} }
func (m *OptOutOfAVSReq) String() string { return proto.CompactTextString(m) }
func (*OptOutOfAVSReq) ProtoMessage()    {}
func (*OptOutOfAVSReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{18}
}
func (m *OptOutOfAVSReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptOutOfAVSReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptOutOfAVSReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptOutOfAVSReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptOutOfAVSReq.Merge(m, src)
}
func (m *OptOutOfAVSReq) XXX_Size() int {
	return m.Size()
}
func (m *OptOutOfAVSReq) XXX_DiscardUnknown() {
	xxx_messageInfo_OptOutOfAVSReq.DiscardUnknown(m)
}

var xxx_messageInfo_OptOutOfAVSReq proto.InternalMessageInfo

// OptOutOfAVSResponse is the response to a opt out of an AVS request.
type OptOutOfAVSResponse struct {
}

func (m *OptOutOfAVSResponse) Reset()         { *m = OptOutOfAVSResponse{} }
func (m *OptOutOfAVSResponse) String() string { return proto.CompactTextString(m) }
func (*OptOutOfAVSResponse) ProtoMessage()    {}
func (*OptOutOfAVSResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{19}
}
func (m *OptOutOfAVSResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OptOutOfAVSResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OptOutOfAVSResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OptOutOfAVSResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptOutOfAVSResponse.Merge(m, src)
}
func (m *OptOutOfAVSResponse) XXX_Size() int {
	return m.Size()
}
func (m *OptOutOfAVSResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OptOutOfAVSResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OptOutOfAVSResponse proto.InternalMessageInfo

// SetConsKeyReq is the request to set the operator's consensus key for an AVS.
type SetConsKeyReq struct {
	// address is the operator address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// avs_address is the address of the AVS.
	AvsAddress string `protobuf:"bytes,2,opt,name=avs_address,json=avsAddress,proto3" json:"avs_address,omitempty"`
	// public_key_json is the consensus public key of the operator in the JSON format, for example:
	// `{"@type":"/cosmos.crypto.ed25519.PubKey","key":"Ui5Gf1+mtWUdH8u3xlmzdKID+F3PK0sfXZ73GZ6q6is="}`
	// there is no need to check for knowledge of the corresponding private key since this is ED25519
	// and not BLS key, where a rogue key attack can take place. however, we should still check for
	// overlap with another operator's key.
	PublicKeyJSON string `protobuf:"bytes,3,opt,name=public_key_json,json=publicKeyJson,proto3" json:"public_key_json,omitempty"`
}

func (m *SetConsKeyReq) Reset()         { *m = SetConsKeyReq{} }
func (m *SetConsKeyReq) String() string { return proto.CompactTextString(m) }
func (*SetConsKeyReq) ProtoMessage()    {}
func (*SetConsKeyReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{20}
}
func (m *SetConsKeyReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetConsKeyReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetConsKeyReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetConsKeyReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetConsKeyReq.Merge(m, src)
}
func (m *SetConsKeyReq) XXX_Size() int {
	return m.Size()
}
func (m *SetConsKeyReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SetConsKeyReq.DiscardUnknown(m)
}

var xxx_messageInfo_SetConsKeyReq proto.InternalMessageInfo

// SetConsKeyResponse is the response to SetConsKeyReq.
type SetConsKeyResponse struct {
}

func (m *SetConsKeyResponse) Reset()         { *m = SetConsKeyResponse{} }
func (m *SetConsKeyResponse) String() string { return proto.CompactTextString(m) }
func (*SetConsKeyResponse) ProtoMessage()    {}
func (*SetConsKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b229d5663e4df167, []int{21}
}
func (m *SetConsKeyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetConsKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetConsKeyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetConsKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetConsKeyResponse.Merge(m, src)
}
func (m *SetConsKeyResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetConsKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetConsKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetConsKeyResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("exocore.operator.v1.SlashType", SlashType_name, SlashType_value)
	proto.RegisterType((*DecValueField)(nil), "exocore.operator.v1.DecValueField")
	proto.RegisterType((*OperatorOptedUSDValue)(nil), "exocore.operator.v1.OperatorOptedUSDValue")
	proto.RegisterType((*OperatorVotingPower)(nil), "exocore.operator.v1.OperatorVotingPower")
	proto.RegisterType((*VotingPowerSnapshot)(nil), "exocore.operator.v1.VotingPowerSnapshot")
	proto.RegisterType((*SnapshotHelper)(nil), "exocore.operator.v1.SnapshotHelper")
	proto.RegisterType((*ClientChainEarningAddrList)(nil), "exocore.operator.v1.ClientChainEarningAddrList")
	proto.RegisterType((*ClientChainEarningAddrInfo)(nil), "exocore.operator.v1.ClientChainEarningAddrInfo")
	proto.RegisterType((*OperatorInfo)(nil), "exocore.operator.v1.OperatorInfo")
	proto.RegisterType((*OptedInfo)(nil), "exocore.operator.v1.OptedInfo")
	proto.RegisterType((*OptedInAssetState)(nil), "exocore.operator.v1.OptedInAssetState")
	proto.RegisterType((*SlashFromUndelegation)(nil), "exocore.operator.v1.SlashFromUndelegation")
	proto.RegisterType((*SlashFromAssetsPool)(nil), "exocore.operator.v1.SlashFromAssetsPool")
	proto.RegisterType((*SlashExecutionInfo)(nil), "exocore.operator.v1.SlashExecutionInfo")
	proto.RegisterType((*OperatorSlashInfo)(nil), "exocore.operator.v1.OperatorSlashInfo")
	proto.RegisterType((*RegisterOperatorReq)(nil), "exocore.operator.v1.RegisterOperatorReq")
	proto.RegisterType((*RegisterOperatorResponse)(nil), "exocore.operator.v1.RegisterOperatorResponse")
	proto.RegisterType((*OptIntoAVSReq)(nil), "exocore.operator.v1.OptIntoAVSReq")
	proto.RegisterType((*OptIntoAVSResponse)(nil), "exocore.operator.v1.OptIntoAVSResponse")
	proto.RegisterType((*OptOutOfAVSReq)(nil), "exocore.operator.v1.OptOutOfAVSReq")
	proto.RegisterType((*OptOutOfAVSResponse)(nil), "exocore.operator.v1.OptOutOfAVSResponse")
	proto.RegisterType((*SetConsKeyReq)(nil), "exocore.operator.v1.SetConsKeyReq")
	proto.RegisterType((*SetConsKeyResponse)(nil), "exocore.operator.v1.SetConsKeyResponse")
}

func init() { proto.RegisterFile("exocore/operator/v1/tx.proto", fileDescriptor_b229d5663e4df167) }

var fileDescriptor_b229d5663e4df167 = []byte{
	// 1787 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x52, 0xb4, 0x2d, 0x3e, 0x92, 0x22, 0x35, 0xf2, 0x07, 0xcd, 0xba, 0x62, 0xbc, 0xa9,
	0x6d, 0x59, 0xad, 0x48, 0x58, 0x69, 0x02, 0xc4, 0x4d, 0x81, 0xea, 0x13, 0x66, 0x23, 0x93, 0xc2,
	0x52, 0x32, 0xd0, 0x14, 0xed, 0x76, 0xb5, 0x1c, 0x92, 0x63, 0x2f, 0x77, 0xb6, 0x3b, 0x43, 0x46,
	0xca, 0xa9, 0xc8, 0x29, 0x28, 0x7a, 0x68, 0x91, 0x53, 0x81, 0x1e, 0x7c, 0x2a, 0x7a, 0xf4, 0x21,
	0x3d, 0x16, 0x6d, 0x6f, 0x39, 0x06, 0x6e, 0x0f, 0x45, 0x0f, 0x4a, 0x21, 0x17, 0x70, 0xff, 0x88,
	0x16, 0x28, 0x66, 0x76, 0x96, 0x1a, 0xda, 0xa4, 0x6c, 0x41, 0x4a, 0x2e, 0x89, 0xf7, 0xbd, 0x37,
	0xef, 0xf7, 0x7b, 0x6f, 0xde, 0xc7, 0x50, 0x70, 0x0d, 0xef, 0x51, 0x97, 0x86, 0xb8, 0x42, 0x03,
	0x1c, 0x3a, 0x9c, 0x86, 0x95, 0xfe, 0x9d, 0x0a, 0xdf, 0x2b, 0x07, 0x21, 0xe5, 0x14, 0xcd, 0x2a,
	0x6d, 0x39, 0xd6, 0x96, 0xfb, 0x77, 0x8a, 0x33, 0x4e, 0x97, 0xf8, 0xb4, 0x22, 0xff, 0x1b, 0xd9,
	0x15, 0xaf, 0xb8, 0x94, 0x75, 0x29, 0xab, 0x74, 0x59, 0x5b, 0x9c, 0xef, 0xb2, 0xb6, 0x52, 0x7c,
	0x4b, 0x29, 0x18, 0x77, 0x1e, 0x11, 0x5f, 0x28, 0x77, 0x31, 0x77, 0xee, 0xc4, 0xdf, 0xca, 0xea,
	0x6a, 0x64, 0x65, 0xcb, 0xaf, 0x4a, 0xf4, 0xa1, 0x54, 0x17, 0xdb, 0xb4, 0x4d, 0x23, 0xb9, 0xf8,
	0x97, 0x92, 0x5e, 0x6b, 0x53, 0xda, 0xf6, 0x70, 0xc5, 0x09, 0x48, 0xc5, 0xf1, 0x7d, 0xca, 0x1d,
	0x4e, 0xa8, 0xaf, 0xce, 0x98, 0x18, 0xb2, 0x6b, 0xd8, 0x7d, 0xe0, 0x78, 0x3d, 0xbc, 0x41, 0xb0,
	0xd7, 0x44, 0xdb, 0x70, 0xde, 0xe9, 0xd2, 0x9e, 0xcf, 0x0b, 0xc6, 0x1b, 0xc6, 0x7c, 0x6a, 0xe5,
	0xbd, 0xcf, 0x0f, 0x4a, 0x13, 0xff, 0x3c, 0x28, 0xdd, 0x6c, 0x13, 0xde, 0xe9, 0xed, 0x96, 0x5d,
	0xda, 0x55, 0xa8, 0xea, 0x7f, 0x8b, 0xac, 0xf9, 0xa8, 0xc2, 0xf7, 0x03, 0xcc, 0xca, 0x6b, 0xd8,
	0x7d, 0xfa, 0xd9, 0x22, 0x28, 0x52, 0x6b, 0xd8, 0xb5, 0x94, 0x2f, 0xf3, 0xbf, 0x09, 0xb8, 0x54,
	0x57, 0x79, 0xa9, 0x07, 0x1c, 0x37, 0x77, 0x1a, 0x6b, 0x12, 0x14, 0x85, 0x30, 0xcd, 0xb0, 0xd7,
	0xb2, 0x7b, 0xac, 0x69, 0xf7, 0x85, 0x44, 0xe1, 0x6e, 0x9e, 0x0c, 0xf7, 0xf0, 0xa0, 0x94, 0x69,
	0x60, 0xaf, 0x15, 0xfb, 0x7d, 0x81, 0x47, 0x46, 0x60, 0xec, 0xb0, 0x66, 0x84, 0xd9, 0x83, 0x1c,
	0xa7, 0xdc, 0xf1, 0x34, 0xd0, 0x84, 0x04, 0xbd, 0x7f, 0x62, 0xd0, 0xec, 0xb6, 0x70, 0x34, 0x06,
	0x35, 0x2b, 0x51, 0x06, 0xb0, 0x7b, 0x90, 0x77, 0x5c, 0x4e, 0xfa, 0x58, 0xc3, 0x9d, 0x94, 0xb8,
	0xb5, 0x13, 0xe3, 0x4e, 0x2f, 0x4b, 0x4f, 0x63, 0x80, 0xa7, 0x23, 0x9c, 0x18, 0xd9, 0xfc, 0xa3,
	0x01, 0xb3, 0x71, 0xfa, 0x1f, 0x50, 0x4e, 0xfc, 0xf6, 0x16, 0xfd, 0x10, 0x87, 0xe8, 0xfb, 0x90,
	0x8d, 0xab, 0xd5, 0x76, 0x9a, 0xcd, 0x50, 0xe5, 0xbe, 0xf0, 0xf4, 0xb3, 0xc5, 0x8b, 0xca, 0xdd,
	0x72, 0xb3, 0x19, 0x62, 0xc6, 0x1a, 0x3c, 0x24, 0x7e, 0xdb, 0xca, 0xc4, 0xe6, 0x42, 0x8c, 0x6c,
	0xc8, 0xf4, 0xa5, 0x37, 0x3b, 0x10, 0xee, 0x54, 0x12, 0x4f, 0x57, 0x31, 0xe9, 0xfe, 0x11, 0x3f,
	0xf3, 0xcb, 0x04, 0xcc, 0x6a, 0x7c, 0x1b, 0xbe, 0x13, 0xb0, 0x0e, 0xe5, 0xe8, 0x21, 0xa0, 0xe8,
	0x02, 0x87, 0xe0, 0xcf, 0xa2, 0x60, 0xf3, 0xd2, 0xaf, 0x9e, 0xa3, 0x9f, 0xc2, 0xe5, 0x41, 0x8e,
	0x74, 0x38, 0x56, 0x48, 0xbc, 0x31, 0x39, 0x9f, 0x5e, 0x9a, 0x2f, 0x8f, 0x68, 0xfc, 0xf2, 0x88,
	0x6c, 0x5b, 0x17, 0xe9, 0xcb, 0x42, 0x86, 0xca, 0x30, 0xeb, 0x39, 0x8c, 0xdb, 0x6e, 0xc7, 0xf1,
	0xdb, 0xb8, 0x69, 0x77, 0x30, 0x69, 0x77, 0xb8, 0x2c, 0x8c, 0x49, 0x6b, 0x46, 0xa8, 0x56, 0x23,
	0xcd, 0x3d, 0xa9, 0x40, 0xb7, 0x21, 0x8f, 0x03, 0xea, 0x76, 0x6c, 0xd2, 0xc4, 0x3e, 0x27, 0x2d,
	0x82, 0xc3, 0x42, 0x52, 0x44, 0x6e, 0xe5, 0xa4, 0xbc, 0x3a, 0x10, 0xa3, 0xeb, 0x90, 0x89, 0x4c,
	0xfd, 0x5e, 0x77, 0x17, 0x87, 0x85, 0x73, 0xd2, 0x67, 0x5a, 0xca, 0x6a, 0x52, 0x64, 0xfe, 0x0c,
	0xa6, 0xe3, 0xac, 0xde, 0xc3, 0x5e, 0x80, 0xc3, 0x71, 0x7c, 0x8c, 0x71, 0x7c, 0xe6, 0x20, 0xdd,
	0x71, 0x98, 0x4d, 0x03, 0x6e, 0xd3, 0x1e, 0x97, 0x35, 0x30, 0x65, 0xa5, 0x3a, 0x0e, 0xab, 0x07,
	0xbc, 0xde, 0xe3, 0xe6, 0x3e, 0x14, 0x57, 0x3d, 0x82, 0x7d, 0x71, 0x8c, 0xf8, 0xeb, 0x4e, 0xe8,
	0x13, 0xbf, 0x2d, 0xca, 0x67, 0x93, 0x30, 0x8e, 0x7e, 0x0c, 0x33, 0x38, 0x12, 0xd9, 0xc4, 0x6f,
	0x51, 0xdb, 0x23, 0x4c, 0x60, 0x89, 0xc4, 0x56, 0x46, 0x26, 0x76, 0xb4, 0xaf, 0xaa, 0xdf, 0xa2,
	0x56, 0x4e, 0x79, 0x12, 0x1f, 0xc2, 0xb9, 0xf9, 0x5b, 0x63, 0x1c, 0xb6, 0x30, 0x41, 0x3f, 0x00,
	0xe4, 0x7d, 0x64, 0xbb, 0xd2, 0x40, 0x84, 0x4b, 0x7c, 0x9b, 0x34, 0x65, 0xa0, 0xc9, 0x95, 0xd9,
	0xc3, 0x83, 0x52, 0x6e, 0xf3, 0x23, 0xed, 0x74, 0x75, 0xcd, 0xca, 0x79, 0x43, 0x82, 0x26, 0x7a,
	0x17, 0xae, 0x0e, 0x1d, 0x8f, 0x43, 0x91, 0xbd, 0x24, 0xbb, 0xc1, 0xba, 0xec, 0x8e, 0x24, 0x60,
	0xfe, 0x35, 0x01, 0x99, 0xb8, 0x48, 0x24, 0x9b, 0x37, 0x21, 0xab, 0x8e, 0x33, 0xad, 0x17, 0xad,
	0x4c, 0x2c, 0x94, 0x1d, 0x77, 0x1d, 0x32, 0x4e, 0x10, 0x84, 0xb4, 0x8f, 0x75, 0x8c, 0xb4, 0x92,
	0x49, 0x93, 0xef, 0x00, 0x1a, 0xd4, 0x6b, 0x17, 0x73, 0x47, 0xe6, 0x35, 0x9a, 0x33, 0x56, 0x3e,
	0xd6, 0xdc, 0xc7, 0xdc, 0x91, 0xa8, 0x1e, 0x14, 0x47, 0x45, 0xa0, 0x28, 0x88, 0xba, 0x3a, 0xd9,
	0x45, 0x88, 0xbc, 0x5b, 0x57, 0x5e, 0x8e, 0x39, 0xa2, 0x7f, 0x1f, 0xc0, 0xa5, 0xdd, 0x2e, 0x61,
	0x8c, 0x50, 0x5f, 0x96, 0x63, 0x7a, 0xc9, 0x2c, 0xab, 0xf6, 0x8b, 0xf7, 0x9c, 0xda, 0x7b, 0xe5,
	0xd5, 0x81, 0xe5, 0x4a, 0x4a, 0xf4, 0xf4, 0x1f, 0x9e, 0x3f, 0x59, 0x30, 0x2c, 0xcd, 0x81, 0xf9,
	0x3b, 0x03, 0x52, 0x72, 0x9b, 0xc8, 0x50, 0x6e, 0xc0, 0x34, 0xf3, 0x1c, 0xd6, 0xb1, 0x5d, 0xea,
	0xf3, 0xd0, 0x71, 0xd5, 0x06, 0xb3, 0xb2, 0x52, 0xba, 0xaa, 0x84, 0xe8, 0x26, 0xe4, 0xa8, 0x38,
	0x63, 0x13, 0x3f, 0xae, 0x6d, 0x91, 0xc5, 0xa4, 0x95, 0xa5, 0x91, 0x2b, 0x55, 0xd7, 0xf3, 0x90,
	0x8f, 0xec, 0x68, 0x8f, 0xeb, 0x4d, 0x99, 0xb4, 0xa6, 0xa5, 0xbc, 0xde, 0xe3, 0xca, 0xf2, 0x32,
	0x9c, 0x7f, 0xe8, 0x10, 0x0f, 0x37, 0x65, 0xbe, 0xa6, 0x2c, 0xf5, 0x65, 0xfe, 0xc9, 0x80, 0x19,
	0x45, 0x6f, 0x99, 0x31, 0xcc, 0x1b, 0xdc, 0xe1, 0xf8, 0x54, 0x0b, 0xb6, 0xea, 0x73, 0x6d, 0x5e,
	0x55, 0x7d, 0x1e, 0x2f, 0x58, 0x64, 0xc1, 0x39, 0x7d, 0x91, 0x9d, 0x6e, 0x08, 0x46, 0xae, 0xcc,
	0xbf, 0x18, 0x70, 0xa9, 0x21, 0x72, 0xb7, 0x11, 0xd2, 0xee, 0x8e, 0xdf, 0xc4, 0x1e, 0x6e, 0xcb,
	0xc7, 0x03, 0xba, 0x0d, 0x29, 0x71, 0x5b, 0x38, 0x8c, 0x1b, 0x26, 0xb5, 0x92, 0x39, 0x3c, 0x28,
	0x4d, 0x35, 0xa4, 0xb0, 0xba, 0x66, 0x4d, 0x45, 0xea, 0x6a, 0x13, 0xdd, 0x84, 0x29, 0x47, 0x04,
	0x2f, 0x2c, 0x23, 0x6e, 0xe9, 0xc3, 0x83, 0xd2, 0x05, 0x99, 0x90, 0xea, 0x9a, 0x75, 0x41, 0x2a,
	0xab, 0xfa, 0xbb, 0x63, 0xf2, 0xec, 0xd2, 0x62, 0x7e, 0x6a, 0xc0, 0xec, 0x20, 0x04, 0x89, 0xc9,
	0xb6, 0x28, 0xf5, 0x86, 0x58, 0x19, 0xaf, 0xc5, 0x2a, 0x71, 0x86, 0xac, 0x7e, 0x93, 0x04, 0x24,
	0x59, 0xad, 0xef, 0x61, 0xb7, 0x27, 0x32, 0x2a, 0x0b, 0xb8, 0x0d, 0xf9, 0xa8, 0x80, 0x83, 0x90,
	0x06, 0x34, 0x14, 0xf2, 0x33, 0xd9, 0x69, 0x39, 0xe9, 0x75, 0x6b, 0xe0, 0x14, 0xfd, 0x04, 0xd2,
	0x11, 0xd0, 0xd9, 0x95, 0x0c, 0x48, 0x87, 0xd1, 0x3b, 0xc7, 0x81, 0xd9, 0xc8, 0x7d, 0x4f, 0xab,
	0x19, 0x56, 0x98, 0x94, 0x53, 0x7d, 0x61, 0xe4, 0x30, 0x19, 0x59, 0x66, 0x2b, 0x49, 0x41, 0xc9,
	0x42, 0xd2, 0x99, 0xae, 0x60, 0xe8, 0x03, 0x98, 0x89, 0x20, 0xe4, 0x45, 0x31, 0x3b, 0xa0, 0xd4,
	0x2b, 0x24, 0x8f, 0xd9, 0xc7, 0x23, 0x8a, 0x40, 0xb9, 0x8f, 0xb2, 0xa3, 0xd5, 0xc6, 0x7b, 0x50,
	0xd4, 0x89, 0xdb, 0x2d, 0xe2, 0x71, 0x1c, 0xc6, 0x23, 0x20, 0xda, 0xa1, 0x05, 0xdd, 0x62, 0x43,
	0x1a, 0xa8, 0x61, 0xf0, 0x0e, 0x5c, 0xe9, 0x10, 0xc6, 0x69, 0x48, 0xdc, 0x17, 0xdf, 0x27, 0xe7,
	0xe5, 0xd1, 0x4b, 0x47, 0x6a, 0xed, 0x1d, 0x60, 0xfe, 0x2f, 0x21, 0x86, 0x45, 0x44, 0x58, 0x92,
	0x3d, 0xc9, 0x4c, 0xbb, 0x0d, 0x79, 0xd6, 0xdb, 0xed, 0x12, 0xce, 0x8f, 0x16, 0x76, 0x42, 0xa2,
	0xe5, 0x06, 0x72, 0xc5, 0x4f, 0xbc, 0x09, 0xfa, 0x62, 0xde, 0x0f, 0xbd, 0x33, 0xd2, 0x52, 0xa6,
	0x4c, 0xbe, 0x01, 0x29, 0xc2, 0xec, 0x3e, 0xe6, 0x74, 0x30, 0xd2, 0xa6, 0x08, 0x7b, 0x20, 0xbf,
	0x47, 0x16, 0xe9, 0xb9, 0xaf, 0xa2, 0x48, 0xbf, 0x09, 0x51, 0x4d, 0xd9, 0xe2, 0x84, 0xcc, 0x5d,
	0xd6, 0x4a, 0x49, 0xc9, 0xf6, 0x7e, 0x80, 0x51, 0x0d, 0xa6, 0x71, 0xdc, 0x3d, 0xd1, 0x8a, 0xbb,
	0x20, 0xd7, 0xc9, 0xad, 0xf1, 0xd7, 0x3f, 0xd4, 0x6d, 0x56, 0x16, 0xeb, 0x9f, 0xe6, 0x9f, 0x0d,
	0x98, 0xb5, 0x70, 0x9b, 0x30, 0x8e, 0xc3, 0xf8, 0x1e, 0x2c, 0xfc, 0x73, 0xf4, 0x3d, 0xc8, 0xb4,
	0x42, 0xda, 0x95, 0xfb, 0x10, 0x33, 0xf6, 0xca, 0x17, 0x72, 0x5a, 0x58, 0x2b, 0x11, 0x7a, 0x1b,
	0x92, 0x92, 0x5a, 0x42, 0x52, 0xbb, 0x7e, 0xec, 0x4b, 0x51, 0x92, 0x92, 0xe6, 0x77, 0xbf, 0xfb,
	0xc9, 0xe3, 0xd2, 0xc4, 0x7f, 0x1e, 0x97, 0x26, 0x3e, 0x7e, 0xfe, 0x64, 0x21, 0xbd, 0x71, 0xe4,
	0xf0, 0x97, 0xcf, 0x9f, 0x2c, 0x5c, 0xd1, 0x92, 0xa9, 0x9f, 0x35, 0x8b, 0x50, 0x78, 0x39, 0x00,
	0x16, 0x50, 0x9f, 0x61, 0xf3, 0x4b, 0x03, 0xb2, 0xf5, 0x80, 0x57, 0x7d, 0x4e, 0x97, 0x1f, 0x34,
	0x4e, 0x1d, 0x57, 0x09, 0xd2, 0x4e, 0x9f, 0x0d, 0xce, 0x46, 0xaf, 0x10, 0x70, 0xfa, 0x2c, 0x36,
	0x78, 0x17, 0x72, 0x41, 0x6f, 0xd7, 0x23, 0xae, 0xfd, 0x08, 0xef, 0xdb, 0x0f, 0x19, 0xf5, 0xd5,
	0x58, 0x9f, 0x11, 0xbf, 0x99, 0xb6, 0xa4, 0xea, 0x7d, 0xbc, 0xff, 0xc3, 0x46, 0xbd, 0x66, 0x65,
	0x83, 0xc1, 0x27, 0xa3, 0xfe, 0xdd, 0xb7, 0x8f, 0x0b, 0xbe, 0x30, 0x14, 0xbc, 0x16, 0x8f, 0x79,
	0x11, 0x90, 0x2e, 0x50, 0x71, 0xff, 0xde, 0x80, 0xe9, 0xe8, 0x1d, 0x5a, 0x6f, 0x7d, 0x1d, 0x81,
	0xdf, 0x7d, 0xe7, 0x38, 0xf6, 0x57, 0x87, 0xd9, 0x6b, 0xac, 0xcc, 0x4b, 0xe2, 0x07, 0x9a, 0x26,
	0x51, 0xfc, 0x9f, 0x1a, 0x90, 0x6d, 0x60, 0xbe, 0x4a, 0x7d, 0xf6, 0x3e, 0xde, 0x17, 0xf4, 0x97,
	0xe0, 0xc2, 0xeb, 0x32, 0x8f, 0x0d, 0xbf, 0xd2, 0xeb, 0xba, 0xa3, 0x07, 0x1c, 0x23, 0xbe, 0x78,
	0x55, 0x43, 0x21, 0x88, 0xab, 0xd2, 0x05, 0x51, 0xa8, 0x0b, 0x1e, 0xa4, 0x1a, 0x83, 0xee, 0x2e,
	0xc2, 0xe5, 0xc6, 0xe6, 0x72, 0xe3, 0x9e, 0xbd, 0xfd, 0xa3, 0xad, 0x75, 0x7b, 0xa7, 0xd6, 0xd8,
	0x5a, 0x5f, 0xad, 0x6e, 0x54, 0xd7, 0xd7, 0xf2, 0x13, 0xe8, 0x1a, 0x14, 0x34, 0x5d, 0xb5, 0xd6,
	0xd8, 0x5e, 0xae, 0x6d, 0xdb, 0x52, 0x94, 0x37, 0xd0, 0x0d, 0xb8, 0xae, 0x69, 0x6b, 0xf5, 0xd8,
	0x60, 0xb9, 0xb6, 0x5e, 0xdf, 0x69, 0x28, 0xb3, 0xc4, 0xd2, 0xdf, 0x93, 0x30, 0x79, 0x9f, 0xb5,
	0xd1, 0x63, 0x03, 0xf2, 0x2f, 0x76, 0x0d, 0x1a, 0xbd, 0x42, 0x46, 0x4c, 0x87, 0xe2, 0xe2, 0x6b,
	0x5a, 0xaa, 0xeb, 0x7c, 0xeb, 0xe3, 0xbf, 0xfd, 0xfb, 0xd3, 0xc4, 0xa2, 0xf9, 0xed, 0xca, 0xe8,
	0x3f, 0x25, 0x55, 0x46, 0x4d, 0xa0, 0x4f, 0x0c, 0x80, 0xa3, 0x7c, 0x21, 0x73, 0xf4, 0x80, 0xd3,
	0x33, 0x5c, 0xbc, 0xf5, 0x4a, 0x1b, 0x45, 0x68, 0x51, 0x12, 0xba, 0x65, 0xde, 0x18, 0x47, 0x68,
	0xb8, 0xf8, 0x04, 0x95, 0xa3, 0x2e, 0x1b, 0x43, 0x65, 0xa8, 0x2f, 0xc7, 0x50, 0x19, 0xd1, 0xaa,
	0xaf, 0xa4, 0x32, 0x3c, 0xbf, 0x7e, 0x65, 0x40, 0x5a, 0xeb, 0x18, 0xf4, 0xe6, 0x38, 0x1c, 0xad,
	0xcb, 0x8a, 0xf3, 0xaf, 0x36, 0x52, 0x6c, 0xca, 0x92, 0xcd, 0xbc, 0x79, 0xf3, 0x18, 0x36, 0xba,
	0xe7, 0x73, 0xbf, 0x10, 0xbf, 0x4e, 0x56, 0x36, 0x3f, 0x3f, 0x9c, 0x33, 0xbe, 0x38, 0x9c, 0x33,
	0xfe, 0x75, 0x38, 0x67, 0xfc, 0xfa, 0xd9, 0xdc, 0xc4, 0x17, 0xcf, 0xe6, 0x26, 0xfe, 0xf1, 0x6c,
	0x6e, 0xe2, 0x83, 0x25, 0x6d, 0x2b, 0xae, 0x47, 0x2e, 0x6b, 0x98, 0x7f, 0x48, 0xc3, 0x47, 0x03,
	0x84, 0xbd, 0x23, 0x0c, 0xb9, 0x25, 0x77, 0xcf, 0xcb, 0xbf, 0xd1, 0xbd, 0xf5, 0xff, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x57, 0x87, 0x4e, 0x6c, 0x79, 0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// RegisterOperator registers a new operator.
	RegisterOperator(ctx context.Context, in *RegisterOperatorReq, opts ...grpc.CallOption) (*RegisterOperatorResponse, error)
	// SetConsKey sets the operator's consensus key for an AVS. To do this, the operator
	// must have previously opted into the AVS.
	SetConsKey(ctx context.Context, in *SetConsKeyReq, opts ...grpc.CallOption) (*SetConsKeyResponse, error)
	// OptIntoAVS opts an operator into an AVS.
	OptIntoAVS(ctx context.Context, in *OptIntoAVSReq, opts ...grpc.CallOption) (*OptIntoAVSResponse, error)
	// OptOutOfAVS opts an operator out of an AVS.
	OptOutOfAVS(ctx context.Context, in *OptOutOfAVSReq, opts ...grpc.CallOption) (*OptOutOfAVSResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) RegisterOperator(ctx context.Context, in *RegisterOperatorReq, opts ...grpc.CallOption) (*RegisterOperatorResponse, error) {
	out := new(RegisterOperatorResponse)
	err := c.cc.Invoke(ctx, "/exocore.operator.v1.Msg/RegisterOperator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetConsKey(ctx context.Context, in *SetConsKeyReq, opts ...grpc.CallOption) (*SetConsKeyResponse, error) {
	out := new(SetConsKeyResponse)
	err := c.cc.Invoke(ctx, "/exocore.operator.v1.Msg/SetConsKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OptIntoAVS(ctx context.Context, in *OptIntoAVSReq, opts ...grpc.CallOption) (*OptIntoAVSResponse, error) {
	out := new(OptIntoAVSResponse)
	err := c.cc.Invoke(ctx, "/exocore.operator.v1.Msg/OptIntoAVS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OptOutOfAVS(ctx context.Context, in *OptOutOfAVSReq, opts ...grpc.CallOption) (*OptOutOfAVSResponse, error) {
	out := new(OptOutOfAVSResponse)
	err := c.cc.Invoke(ctx, "/exocore.operator.v1.Msg/OptOutOfAVS", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// RegisterOperator registers a new operator.
	RegisterOperator(context.Context, *RegisterOperatorReq) (*RegisterOperatorResponse, error)
	// SetConsKey sets the operator's consensus key for an AVS. To do this, the operator
	// must have previously opted into the AVS.
	SetConsKey(context.Context, *SetConsKeyReq) (*SetConsKeyResponse, error)
	// OptIntoAVS opts an operator into an AVS.
	OptIntoAVS(context.Context, *OptIntoAVSReq) (*OptIntoAVSResponse, error)
	// OptOutOfAVS opts an operator out of an AVS.
	OptOutOfAVS(context.Context, *OptOutOfAVSReq) (*OptOutOfAVSResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterOperator(ctx context.Context, req *RegisterOperatorReq) (*RegisterOperatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterOperator not implemented")
}
func (*UnimplementedMsgServer) SetConsKey(ctx context.Context, req *SetConsKeyReq) (*SetConsKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetConsKey not implemented")
}
func (*UnimplementedMsgServer) OptIntoAVS(ctx context.Context, req *OptIntoAVSReq) (*OptIntoAVSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OptIntoAVS not implemented")
}
func (*UnimplementedMsgServer) OptOutOfAVS(ctx context.Context, req *OptOutOfAVSReq) (*OptOutOfAVSResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OptOutOfAVS not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_RegisterOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterOperatorReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exocore.operator.v1.Msg/RegisterOperator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterOperator(ctx, req.(*RegisterOperatorReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetConsKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetConsKeyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetConsKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exocore.operator.v1.Msg/SetConsKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetConsKey(ctx, req.(*SetConsKeyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OptIntoAVS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OptIntoAVSReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OptIntoAVS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exocore.operator.v1.Msg/OptIntoAVS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OptIntoAVS(ctx, req.(*OptIntoAVSReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OptOutOfAVS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OptOutOfAVSReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OptOutOfAVS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/exocore.operator.v1.Msg/OptOutOfAVS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OptOutOfAVS(ctx, req.(*OptOutOfAVSReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "exocore.operator.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterOperator",
			Handler:    _Msg_RegisterOperator_Handler,
		},
		{
			MethodName: "SetConsKey",
			Handler:    _Msg_SetConsKey_Handler,
		},
		{
			MethodName: "OptIntoAVS",
			Handler:    _Msg_OptIntoAVS_Handler,
		},
		{
			MethodName: "OptOutOfAVS",
			Handler:    _Msg_OptOutOfAVS_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "exocore/operator/v1/tx.proto",
}

func (m *DecValueField) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecValueField) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecValueField) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OperatorOptedUSDValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorOptedUSDValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperatorOptedUSDValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ActiveUSDValue.Size()
		i -= size
		if _, err := m.ActiveUSDValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.TotalUSDValue.Size()
		i -= size
		if _, err := m.TotalUSDValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.SelfUSDValue.Size()
		i -= size
		if _, err := m.SelfUSDValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OperatorVotingPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorVotingPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperatorVotingPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.VotingPower.Size()
		i -= size
		if _, err := m.VotingPower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.OperatorAddr) > 0 {
		i -= len(m.OperatorAddr)
		copy(dAtA[i:], m.OperatorAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OperatorAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VotingPowerSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VotingPowerSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VotingPowerSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EpochNumber != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x28
	}
	if len(m.EpochIdentifier) > 0 {
		i -= len(m.EpochIdentifier)
		copy(dAtA[i:], m.EpochIdentifier)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EpochIdentifier)))
		i--
		dAtA[i] = 0x22
	}
	if m.LastChangedHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.LastChangedHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OperatorVotingPowers) > 0 {
		for iNdEx := len(m.OperatorVotingPowers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OperatorVotingPowers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.TotalVotingPower.Size()
		i -= size
		if _, err := m.TotalVotingPower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SnapshotHelper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotHelper) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotHelper) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HasOptOut {
		i--
		if m.HasOptOut {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.LastChangedHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.LastChangedHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientChainEarningAddrList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientChainEarningAddrList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientChainEarningAddrList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EarningInfoList) > 0 {
		for iNdEx := len(m.EarningInfoList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EarningInfoList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ClientChainEarningAddrInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientChainEarningAddrInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientChainEarningAddrInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClientChainEarningAddr) > 0 {
		i -= len(m.ClientChainEarningAddr)
		copy(dAtA[i:], m.ClientChainEarningAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClientChainEarningAddr)))
		i--
		dAtA[i] = 0x12
	}
	if m.LzClientChainID != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.LzClientChainID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OperatorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperatorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Commission.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.ClientChainEarningsAddr != nil {
		{
			size, err := m.ClientChainEarningsAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.OperatorMetaInfo) > 0 {
		i -= len(m.OperatorMetaInfo)
		copy(dAtA[i:], m.OperatorMetaInfo)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OperatorMetaInfo)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ApproveAddr) > 0 {
		i -= len(m.ApproveAddr)
		copy(dAtA[i:], m.ApproveAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ApproveAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EarningsAddr) > 0 {
		i -= len(m.EarningsAddr)
		copy(dAtA[i:], m.EarningsAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EarningsAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OptedInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptedInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptedInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.OptedOutHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OptedOutHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.OptedInHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OptedInHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SlashContract) > 0 {
		i -= len(m.SlashContract)
		copy(dAtA[i:], m.SlashContract)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SlashContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OptedInAssetState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptedInAssetState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptedInAssetState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Value.Size()
		i -= size
		if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SlashFromUndelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashFromUndelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashFromUndelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.AssetID) > 0 {
		i -= len(m.AssetID)
		copy(dAtA[i:], m.AssetID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AssetID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StakerID) > 0 {
		i -= len(m.StakerID)
		copy(dAtA[i:], m.StakerID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.StakerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SlashFromAssetsPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashFromAssetsPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashFromAssetsPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.AssetID) > 0 {
		i -= len(m.AssetID)
		copy(dAtA[i:], m.AssetID)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AssetID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SlashExecutionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashExecutionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashExecutionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HistoricalVotingPower != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.HistoricalVotingPower))
		i--
		dAtA[i] = 0x30
	}
	if m.UndelegationFilterHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.UndelegationFilterHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.SlashAssetsPool) > 0 {
		for iNdEx := len(m.SlashAssetsPool) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlashAssetsPool[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SlashUndelegations) > 0 {
		for iNdEx := len(m.SlashUndelegations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SlashUndelegations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.SlashValue.Size()
		i -= size
		if _, err := m.SlashValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.SlashProportion.Size()
		i -= size
		if _, err := m.SlashProportion.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OperatorSlashInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperatorSlashInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OperatorSlashInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExecutionInfo != nil {
		{
			size, err := m.ExecutionInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.SlashType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SlashType))
		i--
		dAtA[i] = 0x30
	}
	{
		size := m.SlashProportion.Size()
		i -= size
		if _, err := m.SlashProportion.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.IsVetoed {
		i--
		if m.IsVetoed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.EventHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.EventHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.SubmittedHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SubmittedHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SlashContract) > 0 {
		i -= len(m.SlashContract)
		copy(dAtA[i:], m.SlashContract)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SlashContract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterOperatorReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterOperatorReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterOperatorReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterOperatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterOperatorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterOperatorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *OptIntoAVSReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptIntoAVSReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptIntoAVSReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicKeyJSON) > 0 {
		i -= len(m.PublicKeyJSON)
		copy(dAtA[i:], m.PublicKeyJSON)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PublicKeyJSON)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AvsAddress) > 0 {
		i -= len(m.AvsAddress)
		copy(dAtA[i:], m.AvsAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AvsAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OptIntoAVSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptIntoAVSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptIntoAVSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *OptOutOfAVSReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptOutOfAVSReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptOutOfAVSReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AvsAddress) > 0 {
		i -= len(m.AvsAddress)
		copy(dAtA[i:], m.AvsAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AvsAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FromAddress) > 0 {
		i -= len(m.FromAddress)
		copy(dAtA[i:], m.FromAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OptOutOfAVSResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OptOutOfAVSResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OptOutOfAVSResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SetConsKeyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetConsKeyReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetConsKeyReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicKeyJSON) > 0 {
		i -= len(m.PublicKeyJSON)
		copy(dAtA[i:], m.PublicKeyJSON)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PublicKeyJSON)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AvsAddress) > 0 {
		i -= len(m.AvsAddress)
		copy(dAtA[i:], m.AvsAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AvsAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetConsKeyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetConsKeyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetConsKeyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DecValueField) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *OperatorOptedUSDValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SelfUSDValue.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TotalUSDValue.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.ActiveUSDValue.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *OperatorVotingPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OperatorAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.VotingPower.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *VotingPowerSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TotalVotingPower.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.OperatorVotingPowers) > 0 {
		for _, e := range m.OperatorVotingPowers {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.LastChangedHeight != 0 {
		n += 1 + sovTx(uint64(m.LastChangedHeight))
	}
	l = len(m.EpochIdentifier)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.EpochNumber != 0 {
		n += 1 + sovTx(uint64(m.EpochNumber))
	}
	return n
}

func (m *SnapshotHelper) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastChangedHeight != 0 {
		n += 1 + sovTx(uint64(m.LastChangedHeight))
	}
	if m.HasOptOut {
		n += 2
	}
	return n
}

func (m *ClientChainEarningAddrList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EarningInfoList) > 0 {
		for _, e := range m.EarningInfoList {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *ClientChainEarningAddrInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LzClientChainID != 0 {
		n += 1 + sovTx(uint64(m.LzClientChainID))
	}
	l = len(m.ClientChainEarningAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *OperatorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EarningsAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ApproveAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OperatorMetaInfo)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ClientChainEarningsAddr != nil {
		l = m.ClientChainEarningsAddr.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Commission.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *OptedInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SlashContract)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OptedInHeight != 0 {
		n += 1 + sovTx(uint64(m.OptedInHeight))
	}
	if m.OptedOutHeight != 0 {
		n += 1 + sovTx(uint64(m.OptedOutHeight))
	}
	if m.Jailed {
		n += 2
	}
	return n
}

func (m *OptedInAssetState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Value.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *SlashFromUndelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StakerID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AssetID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *SlashFromAssetsPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AssetID)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *SlashExecutionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SlashProportion.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.SlashValue.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.SlashUndelegations) > 0 {
		for _, e := range m.SlashUndelegations {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.SlashAssetsPool) > 0 {
		for _, e := range m.SlashAssetsPool {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.UndelegationFilterHeight != 0 {
		n += 1 + sovTx(uint64(m.UndelegationFilterHeight))
	}
	if m.HistoricalVotingPower != 0 {
		n += 1 + sovTx(uint64(m.HistoricalVotingPower))
	}
	return n
}

func (m *OperatorSlashInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SlashContract)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SubmittedHeight != 0 {
		n += 1 + sovTx(uint64(m.SubmittedHeight))
	}
	if m.EventHeight != 0 {
		n += 1 + sovTx(uint64(m.EventHeight))
	}
	if m.IsVetoed {
		n += 2
	}
	l = m.SlashProportion.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.SlashType != 0 {
		n += 1 + sovTx(uint64(m.SlashType))
	}
	if m.ExecutionInfo != nil {
		l = m.ExecutionInfo.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *RegisterOperatorReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *RegisterOperatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OptIntoAVSReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AvsAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PublicKeyJSON)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *OptIntoAVSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *OptOutOfAVSReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AvsAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *OptOutOfAVSResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SetConsKeyReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AvsAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PublicKeyJSON)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *SetConsKeyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DecValueField) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecValueField: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecValueField: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorOptedUSDValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorOptedUSDValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorOptedUSDValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfUSDValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SelfUSDValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUSDValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalUSDValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveUSDValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ActiveUSDValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorVotingPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorVotingPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorVotingPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.VotingPower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VotingPowerSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VotingPowerSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VotingPowerSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalVotingPower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalVotingPower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorVotingPowers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorVotingPowers = append(m.OperatorVotingPowers, &OperatorVotingPower{})
			if err := m.OperatorVotingPowers[len(m.OperatorVotingPowers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChangedHeight", wireType)
			}
			m.LastChangedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastChangedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotHelper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotHelper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotHelper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastChangedHeight", wireType)
			}
			m.LastChangedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastChangedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasOptOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasOptOut = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientChainEarningAddrList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientChainEarningAddrList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientChainEarningAddrList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarningInfoList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarningInfoList = append(m.EarningInfoList, &ClientChainEarningAddrInfo{})
			if err := m.EarningInfoList[len(m.EarningInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientChainEarningAddrInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientChainEarningAddrInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientChainEarningAddrInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LzClientChainID", wireType)
			}
			m.LzClientChainID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LzClientChainID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientChainEarningAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientChainEarningAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarningsAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarningsAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproveAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApproveAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorMetaInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorMetaInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientChainEarningsAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientChainEarningsAddr == nil {
				m.ClientChainEarningsAddr = &ClientChainEarningAddrList{}
			}
			if err := m.ClientChainEarningsAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptedInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptedInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptedInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptedInHeight", wireType)
			}
			m.OptedInHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptedInHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OptedOutHeight", wireType)
			}
			m.OptedOutHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OptedOutHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptedInAssetState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptedInAssetState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptedInAssetState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashFromUndelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashFromUndelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashFromUndelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashFromAssetsPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashFromAssetsPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashFromAssetsPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssetID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashExecutionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashExecutionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashExecutionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashProportion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SlashProportion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SlashValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashUndelegations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashUndelegations = append(m.SlashUndelegations, SlashFromUndelegation{})
			if err := m.SlashUndelegations[len(m.SlashUndelegations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashAssetsPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashAssetsPool = append(m.SlashAssetsPool, SlashFromAssetsPool{})
			if err := m.SlashAssetsPool[len(m.SlashAssetsPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndelegationFilterHeight", wireType)
			}
			m.UndelegationFilterHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UndelegationFilterHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoricalVotingPower", wireType)
			}
			m.HistoricalVotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoricalVotingPower |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperatorSlashInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperatorSlashInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperatorSlashInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedHeight", wireType)
			}
			m.SubmittedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventHeight", wireType)
			}
			m.EventHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsVetoed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsVetoed = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashProportion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SlashProportion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashType", wireType)
			}
			m.SlashType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecutionInfo == nil {
				m.ExecutionInfo = &SlashExecutionInfo{}
			}
			if err := m.ExecutionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterOperatorReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterOperatorReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterOperatorReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &OperatorInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterOperatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterOperatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterOperatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptIntoAVSReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptIntoAVSReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptIntoAVSReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvsAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvsAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyJSON", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyJSON = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptIntoAVSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptIntoAVSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptIntoAVSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptOutOfAVSReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptOutOfAVSReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptOutOfAVSReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvsAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvsAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OptOutOfAVSResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OptOutOfAVSResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OptOutOfAVSResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetConsKeyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetConsKeyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetConsKeyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvsAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AvsAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyJSON", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyJSON = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetConsKeyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetConsKeyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetConsKeyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
